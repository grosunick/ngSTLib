/*******************************************************************************
* Filename      : Tim3FieldValues.hpp
*
* Details       : Enumerations related with TIM3 peripheral. This header file is
*                 auto-generated for STM32L152 device.
*
*
*******************************************************************************/

#pragma once

#include <register/FieldValue.hpp>

using namespace ng;

/**
 * Clock division
 *
 * This bit-field indicates the division ratio between the timer clock (CK_INT) frequency and
 * sampling clock used by the digital filters (ETR, TIx),
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CR1_CKD_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 00: tDTS = tCK_INT
    using ClockInt = FieldValue<TIM3_CR1_CKD_Values, 0U, BaseType>;
    // 01: tDTS = 2 × tCK_INT
    using ClockIntMul2 = FieldValue<TIM3_CR1_CKD_Values, 1U, BaseType>;
    // 10: tDTS = 4 × tCK_INT
    using ClockIntMul4 = FieldValue<TIM3_CR1_CKD_Values, 2U, BaseType>;
};

/** Auto-reload preload enable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CR1_ARPE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // register is not buffered
    using NotBuffered = FieldValue<TIM3_CR1_ARPE_Values, 0U, BaseType>;
    // register is buffered
    using Buffered = FieldValue<TIM3_CR1_ARPE_Values, 1U, BaseType>;
};

/**  Center-aligned mode selection */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CR1_CMS_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /** 00: Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR). */
    using EdgeAligned = FieldValue<TIM3_CR1_CMS_Values, 0U, BaseType>;
    /**
     * 01: Center-aligned mode 1. The counter counts up and down alternatively. Output compare
     * interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set
     * only when the counter is counting down.
     */
    using CenterAligned1 = FieldValue<TIM3_CR1_CMS_Values, 1U, BaseType>;
    /**
     * 10: Center-aligned mode 2. The counter counts up and down alternatively. Output compare
     * interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set
     * only when the counter is counting up.
     */
    using CenterAligned2 = FieldValue<TIM3_CR1_CMS_Values, 2U, BaseType>;
    /**
     * 11: Center-aligned mode 3. The counter counts up and down alternatively. Output compare
     * interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set
     * both when the counter is counting up or down.
     */
    using CenterAligned3 = FieldValue<TIM3_CR1_CMS_Values, 3U, BaseType>;
};

/** Direction */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CR1_DIR_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Up = FieldValue<TIM3_CR1_DIR_Values, 0U, BaseType>;
    using Down = FieldValue<TIM3_CR1_DIR_Values, 1U, BaseType>;
};

/** One-pulse mode */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CR1_OPM_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // Counter is not stopped at update event
    using Disable = FieldValue<TIM3_CR1_OPM_Values, 0U, BaseType>;
    // Counter stops counting at the next update event (clearing the CEN bit).
    using Enable = FieldValue<TIM3_CR1_OPM_Values, 1U, BaseType>;
};
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CR1_URS_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /**
     * This bit is set and cleared by software to select the UEV event sources.
     * 0: Any of the following events generates an update interrupt or DMA request if enabled.
     * These events can be:
     *   – Counter overflow/underflow
     *   – Setting the UG bit
     *   – Update generation through the slave mode controller
     */
    using AllEvents = FieldValue<TIM3_CR1_URS_Values, 0U, BaseType>;
    /** 1: Only counter overflow/underflow generates an update interrupt or DMA request if enabled. */
    using CounterOverflow = FieldValue<TIM3_CR1_URS_Values, 1U, BaseType>;
};

/** Update disable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CR1_UDIS_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /**
     * 0: UEV enabled. The Update (UEV) event is generated by one of the following events:
     *
     *   – Counter overflow/underflow
     *   – Setting the UG bit
     *   – Update generation through the slave mode controller
     *
     * Buffered registers are then loaded with their preload values.
     */
    using UEVEnabled = FieldValue<TIM3_CR1_UDIS_Values, 0U, BaseType>;
    /**
     * 1: UEV disabled. The Update event is not generated, shadow registers keep their value
     * (ARR, PSC). However the counter and the prescaler are reinitialized if the UG bit is set or if
     * a hardware reset is received from the slave mode controller.
     */
    using UEVDisabled = FieldValue<TIM3_CR1_UDIS_Values, 1U, BaseType>;
};

/** Counter enable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CR1_CEN_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Disable = FieldValue<TIM3_CR1_CEN_Values, 0U, BaseType>;
    using Enable = FieldValue<TIM3_CR1_CEN_Values, 1U, BaseType>;
};

/** TI1 selection */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CR2_TI1S_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 0: The TIMx_CH1 pin is connected to TI1 input
    using Value0 = FieldValue<TIM3_CR2_TI1S_Values, 0U, BaseType>;
    // 1: The TIMx_CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination)
    using Value1 = FieldValue<TIM3_CR2_TI1S_Values, 1U, BaseType>;
};

/**
 * Master mode selection
 *
 * These bits can be used to select the information to be sent in master mode to slave timers
 * for synchronization (TRGO).
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CR2_MMS_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /**
     * 000: Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO). If the
     * reset is generated by the trigger input (slave mode controller configured in reset mode) then
     * the signal on TRGO is delayed compared to the actual reset.
     */
    using Reset = FieldValue<TIM3_CR2_MMS_Values, 0U, BaseType>;
    /**
     * 001: Enable - the Counter enable signal, CNT_EN, is used as trigger output (TRGO). It is
     * useful to start several timers at the same time or to control a window in which a slave timer is
     * enabled. The Counter Enable signal is generated by a logic OR between CEN control bit
     * and the trigger input when configured in gated mode.
     * When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO,
     * except if the master/slave mode is selected (see the MSM bit description in TIMx_SMCR register).
     */
    using Enable = FieldValue<TIM3_CR2_MMS_Values, 1U, BaseType>;
    /**
     * 010: Update - The update event is selected as trigger output (TRGO). For instance a master
     * timer can then be used as a prescaler for a slave timer.
     */
    using Update = FieldValue<TIM3_CR2_MMS_Values, 2U, BaseType>;
    /**
     * 011: Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be
     * set (even if it was already high), as soon as a capture or a compare match occurred. (TRGO)
     */
    using ComparePulse = FieldValue<TIM3_CR2_MMS_Values, 3U, BaseType>;
    // 100: Compare - OC1REF signal is used as trigger output (TRGO)
    using CompareOC1REF = FieldValue<TIM3_CR2_MMS_Values, 4U, BaseType>;
    // 101: Compare - OC2REF signal is used as trigger output (TRGO)
    using CompareOC2REF = FieldValue<TIM3_CR2_MMS_Values, 5U, BaseType>;
    // 110: Compare - OC3REF signal is used as trigger output (TRGO)
    using CompareOC3REF = FieldValue<TIM3_CR2_MMS_Values, 6U, BaseType>;
    // CompareOC4REF signal is used as trigger output (TRGO)
    using CompareOC4REF = FieldValue<TIM3_CR2_MMS_Values, 7U, BaseType>;
};

/** Capture/compare DMA selection */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CR2_CCDS_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 0: CCx DMA request sent when CCx event occurs
    using CCEvent = FieldValue<TIM3_CR2_CCDS_Values, 0U, BaseType>;
    // 1: CCx DMA requests sent when update event occurs
    using UpdateEvent = FieldValue<TIM3_CR2_CCDS_Values, 1U, BaseType>;
};

/**
 * External trigger polarity
 *
 * This bit selects whether ETR or ETR is used for trigger operations
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_SMCR_ETP_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 0: ETR is non-inverted, active at high level or rising edge
    using NonInverted = FieldValue<TIM3_SMCR_ETP_Values, 0U, BaseType>;
    // 1: ETR is inverted, active at low level or falling edge
    using Inverted = FieldValue<TIM3_SMCR_ETP_Values, 1U, BaseType>;
};

/**
 * External clock enable
 *
 * This bit enables External clock mode 2
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_SMCR_ECE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 0: External clock mode 2 disabled
    using Disable = FieldValue<TIM3_SMCR_ECE_Values, 0U, BaseType>;
    /**
     * External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.
     * 1: Setting the ECE bit has the same effect as selecting external clock mode 1 with TRGI
     *    connected to ETRF (SMS=111 and TS=111).
     * 2: It is possible to simultaneously use external clock mode 2 with the following slave modes: reset mode,
     *    gated mode and trigger mode. Nevertheless, TRGI must not be connected to ETRF in this case
     *    (TS bits must not be 111).
     * 3: If external clock mode 1 and external clock mode 2 are enabled at the same time, the external
     *    clock input is ETRF.
     */
    using Enable = FieldValue<TIM3_SMCR_ECE_Values, 1U, BaseType>;
};

/**
 * External trigger prescaler
 *
 * External trigger signal ETRP frequency must be at most 1/4 of CK_INT frequency. A prescaler can be enabled
 * to reduce ETRP frequency. It is useful when inputting fast external clocks.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_SMCR_ETPS_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 00: Prescaler OFF
    using Off = FieldValue<TIM3_SMCR_ETPS_Values, 0U, BaseType>;
    // 01: ETRP frequency divided by 2
    using DivBy2 = FieldValue<TIM3_SMCR_ETPS_Values, 1U, BaseType>;
    // 10: ETRP frequency divided by 4
    using DivBy4 = FieldValue<TIM3_SMCR_ETPS_Values, 2U, BaseType>;
    // 11: ETRP frequency divided by 8
    using DivBy8 = FieldValue<TIM3_SMCR_ETPS_Values, 3U, BaseType>;
};

/**
 * External trigger filter
 *
 * This bit-field then defines the frequency used to sample ETRP signal and the length of the
 * digital filter applied to ETRP. The digital filter is made of an event counter in which N
 * consecutive events are needed to validate a transition on the output:
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_SMCR_ETF_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 0000: No filter, sampling is done at fDTS
    using No = FieldValue<TIM3_SMCR_ETF_Values, 0U, BaseType>;
    // 0001: fSAMPLING=fCK_INT, N=2
    using CKintDiv0N2 = FieldValue<TIM3_SMCR_ETF_Values, 1U, BaseType>;
    // 0010: fSAMPLING=fCK_INT, N=4
    using CKintDiv0N4 = FieldValue<TIM3_SMCR_ETF_Values, 2U, BaseType>;
    // 0011: fSAMPLING=fCK_INT, N=8
    using CKintDiv0N8 = FieldValue<TIM3_SMCR_ETF_Values, 3U, BaseType>;
    // 0100: fSAMPLING=fDTS/2, N=6
    using CKintDiv2N6 = FieldValue<TIM3_SMCR_ETF_Values, 4U, BaseType>;
    // 0101: fSAMPLING=fDTS/2, N=8
    using CKintDiv2N8 = FieldValue<TIM3_SMCR_ETF_Values, 5U, BaseType>;
    // 0110: fSAMPLING=fDTS/4, N=6
    using CKintDiv4N6 = FieldValue<TIM3_SMCR_ETF_Values, 6U, BaseType>;
    // 0111: fSAMPLING=fDTS/4, N=8
    using CKintDiv4N8 = FieldValue<TIM3_SMCR_ETF_Values, 7U, BaseType>;
    // 1000: fSAMPLING=fDTS/8, N=6
    using CKintDiv8N6 = FieldValue<TIM3_SMCR_ETF_Values, 8U, BaseType>;
    // 1001: fSAMPLING=fDTS/8, N=8
    using CKintDiv8N8 = FieldValue<TIM3_SMCR_ETF_Values, 9U, BaseType>;
    // 1010: fSAMPLING=fDTS/16, N=5
    using CKintDiv16N5 = FieldValue<TIM3_SMCR_ETF_Values, 10U, BaseType>;
    // 1011: fSAMPLING=fDTS/16, N=6
    using CKintDiv16N6 = FieldValue<TIM3_SMCR_ETF_Values, 11U, BaseType>;
    // 1100: fSAMPLING=fDTS/16, N=8
    using CKintDiv16N8 = FieldValue<TIM3_SMCR_ETF_Values, 12U, BaseType>;
    // 1101: fSAMPLING=fDTS/32, N=5
    using CKintDiv32N5 = FieldValue<TIM3_SMCR_ETF_Values, 13U, BaseType>;
    // 1110: fSAMPLING=fDTS/32, N=6
    using CKintDiv32N6 = FieldValue<TIM3_SMCR_ETF_Values, 14U, BaseType>;
    // 1111: fSAMPLING=fDTS/32, N=8
    using CKintDiv32N8 = FieldValue<TIM3_SMCR_ETF_Values, 15U, BaseType>;
};

/** Master/Slave mode */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_SMCR_MSM_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 0: No action
    using Disable = FieldValue<TIM3_SMCR_MSM_Values, 0U, BaseType>;
    /**
     * The effect of an event on the trigger input (TRGI) is delayed to allow a perfect
     * synchronization between the current timer and its slaves (through TRGO). It is useful if we
     * want to synchronize several timers on a single external event.
     */
    using Enable = FieldValue<TIM3_SMCR_MSM_Values, 1U, BaseType>;
};

/**
 * Trigger selection
 *
 * This bit-field selects the trigger input to be used to synchronize the counter.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_SMCR_TS_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 000: Internal Trigger 0 (ITR0).
    using ITR0 = FieldValue<TIM3_SMCR_TS_Values, 0U, BaseType>;
    // 001: Internal Trigger 1 (ITR1).
    using ITR1 = FieldValue<TIM3_SMCR_TS_Values, 1U, BaseType>;
    // 010: Internal Trigger 2 (ITR2).
    using ITR2 = FieldValue<TIM3_SMCR_TS_Values, 2U, BaseType>;
    // 011: Internal Trigger 3 (ITR3).
    using ITR3 = FieldValue<TIM3_SMCR_TS_Values, 3U, BaseType>;
    // 100: TI1 Edge Detector (TI1F_ED)
    using TI1F_ED = FieldValue<TIM3_SMCR_TS_Values, 4U, BaseType>;
    // 101: Filtered Timer Input 1 (TI1FP1)
    using TI1FP1 = FieldValue<TIM3_SMCR_TS_Values, 5U, BaseType>;
    // 110: Filtered Timer Input 2 (TI2FP2)
    using TI2FP2 = FieldValue<TIM3_SMCR_TS_Values, 6U, BaseType>;
    // 111: External Trigger input (ETRF)
    using ETRF = FieldValue<TIM3_SMCR_TS_Values, 7U, BaseType>;
};

/**
 * OCREF clear selection
 *
 * This bit is used to select the OCREF clear source
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_SMCR_OCCS_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 0: OCREF_CLR_INT is connected to the OCREF_CLR input
    using OCREF_CLR = FieldValue<TIM3_SMCR_OCCS_Values, 0U, BaseType>;
    // 1: OCREF_CLR_INT is connected to ETRF
    using ETRF = FieldValue<TIM3_SMCR_OCCS_Values, 1U, BaseType>;
};

/**
 * Slave mode selection
 *
 * When external signals are selected the active edge of the trigger signal (TRGI) is linked to
 * the polarity selected on the external input (see Input Control register and Control register description.
 *
 * Note: The gated mode must not be used if TI1F_ED is selected as the trigger input (TS=100).
 *       Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas the gated mode checks the level
 *       of the trigger signal. The clock of the slave timer must be enabled prior to receiving events from the master
 *       timer, and must not be changed on-the-fly while triggers are received from the master timer.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_SMCR_SMS_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 000: Slave mode disabled - if CEN = ‘1 then the prescaler is clocked directly by the internal clock.
    using Disable = FieldValue<TIM3_SMCR_SMS_Values, 0U, BaseType>;
    // 001: Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level.
    using EncoderMode1 = FieldValue<TIM3_SMCR_SMS_Values, 1U, BaseType>;
    // 010: Encoder mode 2 - Counter counts up/down on TI2FP2 edge depending on TI1FP1 level.
    using EncoderMode2 = FieldValue<TIM3_SMCR_SMS_Values, 2U, BaseType>;
    /**
     * 011: Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges
     * depending on the level of the other input.
     */
    using EncoderMode3 = FieldValue<TIM3_SMCR_SMS_Values, 3U, BaseType>;
    /**
     * 100: Reset mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter
     * and generates an update of the registers.
     */
    using ResetMode = FieldValue<TIM3_SMCR_SMS_Values, 4U, BaseType>;
    /**
     * 101: Gated mode - The counter clock is enabled when the trigger input (TRGI) is high. The
     * counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of
     * the counter are controlled.
     */
    using GatedMode = FieldValue<TIM3_SMCR_SMS_Values, 5U, BaseType>;
    /**
     * 110: Trigger mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset).
     * Only the start of the counter is controlled.
     */
    using TriggerMode = FieldValue<TIM3_SMCR_SMS_Values, 6U, BaseType>;
    // 111: External Clock mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.
    using ExternalClockMode = FieldValue<TIM3_SMCR_SMS_Values, 7U, BaseType>;
};

/** Trigger DMA request enable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_DIER_TDE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Disable = FieldValue<TIM3_DIER_TDE_Values, 0U, BaseType>;
    using Enable = FieldValue<TIM3_DIER_TDE_Values, 1U, BaseType>;
};

/**  Capture/Compare 4 DMA request enable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_DIER_CC4DE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Disable = FieldValue<TIM3_DIER_CC4DE_Values, 0U, BaseType>;
    using Enable = FieldValue<TIM3_DIER_CC4DE_Values, 1U, BaseType>;
};

/** Capture/Compare 3 DMA request enable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_DIER_CC3DE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Disable = FieldValue<TIM3_DIER_CC3DE_Values, 0U, BaseType>;
    using Enable = FieldValue<TIM3_DIER_CC3DE_Values, 1U, BaseType>;
};

/** Capture/Compare 2 DMA request enable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_DIER_CC2DE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Disable = FieldValue<TIM3_DIER_CC2DE_Values, 0U, BaseType>;
    using Enable = FieldValue<TIM3_DIER_CC2DE_Values, 1U, BaseType>;
};

/** Capture/Compare 1 DMA request enable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_DIER_CC1DE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Disable = FieldValue<TIM3_DIER_CC1DE_Values, 0U, BaseType>;
    using Enable = FieldValue<TIM3_DIER_CC1DE_Values, 1U, BaseType>;
};

/** Update DMA request enable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_DIER_UDE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Disable = FieldValue<TIM3_DIER_UDE_Values, 0U, BaseType>;
    using Enable = FieldValue<TIM3_DIER_UDE_Values, 1U, BaseType>;
};

/** Trigger interrupt enable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_DIER_TIE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Disable = FieldValue<TIM3_DIER_TIE_Values, 0U, BaseType>;
    using Enable = FieldValue<TIM3_DIER_TIE_Values, 1U, BaseType>;
};

/** Capture/Compare 4 interrupt enable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_DIER_CC4IE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Disable = FieldValue<TIM3_DIER_CC4IE_Values, 0U, BaseType>;
    using Enable = FieldValue<TIM3_DIER_CC4IE_Values, 1U, BaseType>;
};

/** : Capture/Compare 3 interrupt enable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_DIER_CC3IE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Disable = FieldValue<TIM3_DIER_CC3IE_Values, 0U, BaseType>;
    using Enable = FieldValue<TIM3_DIER_CC3IE_Values, 1U, BaseType>;
};

/** Capture/Compare 2 interrupt enable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_DIER_CC2IE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Disable = FieldValue<TIM3_DIER_CC2IE_Values, 0U, BaseType>;
    using Enable = FieldValue<TIM3_DIER_CC2IE_Values, 1U, BaseType>;
};

/** Capture/Compare 1 interrupt enable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_DIER_CC1IE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Disable = FieldValue<TIM3_DIER_CC1IE_Values, 0U, BaseType>;
    using Enable = FieldValue<TIM3_DIER_CC1IE_Values, 1U, BaseType>;
};

/** Update interrupt enable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_DIER_UIE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Disable = FieldValue<TIM3_DIER_UIE_Values, 0U, BaseType>;
    using Enable = FieldValue<TIM3_DIER_UIE_Values, 1U, BaseType>;
};

/** Capture/Compare 4 overcapture flag */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_SR_CC4OF_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 0: No overcapture has been detected
    using Cleared = FieldValue<TIM3_SR_CC4OF_Values, 0U, BaseType>;
    // 1: The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set
    using Updated = FieldValue<TIM3_SR_CC4OF_Values, 1U, BaseType>;
};

/** Capture/Compare 3 overcapture flag */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_SR_CC3OF_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 0: No overcapture has been detected
    using Cleared = FieldValue<TIM3_SR_CC3OF_Values, 0U, BaseType>;
    // 1: The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set
    using Updated = FieldValue<TIM3_SR_CC3OF_Values, 1U, BaseType>;
};

/** Capture/compare 2 overcapture flag */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_SR_CC2OF_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 0: No overcapture has been detected
    using Cleared = FieldValue<TIM3_SR_CC2OF_Values, 0U, BaseType>;
    // 1: The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set
    using Updated = FieldValue<TIM3_SR_CC2OF_Values, 1U, BaseType>;
};

/**
 * Capture/Compare 1 overcapture flag
 *
 * This flag is set by hardware only when the corresponding channel is configured in input capture mode.
 * It is cleared by software by writing it to ‘0.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_SR_CC1OF_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 0: No overcapture has been detected
    using Cleared = FieldValue<TIM3_SR_CC1OF_Values, 0U, BaseType>;
    // 1: The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set
    using Updated = FieldValue<TIM3_SR_CC1OF_Values, 1U, BaseType>;
};

/**
 * Trigger interrupt flag
 *
 * This flag is set by hardware on trigger event (active edge detected on TRGI input when the slave mode controller
 * is enabled in all modes but gated mode. It is set when the counter starts or stops when gated mode is selected.
 * It is cleared by software.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_SR_TIF_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 0: No trigger event occurred
    using Cleared = FieldValue<TIM3_SR_TIF_Values, 0U, BaseType>;
    // 1: Trigger interrupt pending
    using Value1 = FieldValue<TIM3_SR_TIF_Values, 1U, BaseType>;
};

/**
 * Capture/Compare 4 interrupt flag
 *
 * refer to CC1IF description
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_SR_CC4IF_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Cleared = FieldValue<TIM3_SR_CC4IF_Values, 0U, BaseType>;
    using Updated = FieldValue<TIM3_SR_CC4IF_Values, 1U, BaseType>;
};

/**
 * Capture/Compare 3 interrupt flag
 *
 * refer to CC1IF description
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_SR_CC3IF_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Cleared = FieldValue<TIM3_SR_CC3IF_Values, 0U, BaseType>;
    using Updated = FieldValue<TIM3_SR_CC3IF_Values, 1U, BaseType>;
};

/**
 * Capture/Compare 2 interrupt flag
 *
 * refer to CC1IF description
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_SR_CC2IF_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Cleared = FieldValue<TIM3_SR_CC2IF_Values, 0U, BaseType>;
    using Updated = FieldValue<TIM3_SR_CC2IF_Values, 1U, BaseType>;
};

/**
 * Capture/Compare 1 interrupt flag
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_SR_CC1IF_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /**
     * If channel CC1 is configured as output:
     *
     * This flag is set by hardware when the counter matches the compare value, with some
     * exception in center-aligned mode (refer to the CMS bits in the TIMx_CR1 register description).
     * It is cleared by software.
     *
     * 0: No match
     *
     * If channel CC1 is configured as input: this bit is set by hardware on a capture.
     * It is cleared by software or by reading the TIMx_CCR1 register.
     *
     * 0: No input capture occurred
     */
    using Cleared = FieldValue<TIM3_SR_CC1IF_Values, 0U, BaseType>;
    
    /**
     * If channel CC1 is configured as output:
     *
     * This flag is set by hardware when the counter matches the compare value, with some
     * exception in center-aligned mode (refer to the CMS bits in the TIMx_CR1 register description).
     * It is cleared by software.
     *
     * 1: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the contents of
     * TIMx_CCR1 are greater than the contents of TIMx_ARR, the CC1IF bit goes high on the counter overflow
     * (in upcounting and up/down-counting modes) or underflow (in downcounting mode)
     *
     * If channel CC1 is configured as input: this bit is set by hardware on a capture.
     * It is cleared by software or by reading the TIMx_CCR1 register.
     *
     * 1: The counter value has been captured in TIMx_CCR1 register (An edge has been detected on IC1 which
     * matches the selected polarity)
     */
    using Updated = FieldValue<TIM3_SR_CC1IF_Values, 1U, BaseType>;
};

/**
 * Update interrupt flag.
 * This bit is set by hardware on an update event. It is cleared by software.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_SR_UIF_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // No update occurred.
    using Cleared = FieldValue<TIM3_SR_UIF_Values, 0U, BaseType>;
    /**
     * Update interrupt pending. This bit is set by hardware when the registers are updated:
     *   – At overflow or underflow and if UDIS = 0 in the TIMx_CR1 register.
     *   – When CNT is reinitialized by software using the UG bit in the TIMx_EGR register, if URS = 0
     *     and UDIS = 0 in the TIMx_CR1 register.
     */
    using Updated = FieldValue<TIM3_SR_UIF_Values, 1U, BaseType>;
};

/**
 * Trigger generation
 *
 * This bit is set by software in order to generate an event, it is automatically cleared by hardware.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_EGR_TG_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 0: No action
    using Cleared = FieldValue<TIM3_EGR_TG_Values, 0U, BaseType>;
    // 1: The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled.
    using Generate = FieldValue<TIM3_EGR_TG_Values, 1U, BaseType>;
};

/**
 * Capture/compare 4 generation
 *
 * refer to CC1G description
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_EGR_CC4G_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Cleared = FieldValue<TIM3_EGR_CC4G_Values, 0U, BaseType>;
    using Generate = FieldValue<TIM3_EGR_CC4G_Values, 1U, BaseType>;
};

/**
 * Capture/compare 3 generation
 *
 * refer to CC1G description
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_EGR_CC3G_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Cleared = FieldValue<TIM3_EGR_CC3G_Values, 0U, BaseType>;
    using Generate = FieldValue<TIM3_EGR_CC3G_Values, 1U, BaseType>;
};

/**
 * Capture/compare 2 generation
 *
 * refer to CC1G description
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_EGR_CC2G_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Cleared = FieldValue<TIM3_EGR_CC2G_Values, 0U, BaseType>;
    using Generate = FieldValue<TIM3_EGR_CC2G_Values, 1U, BaseType>;
};

/**
 * Capture/compare 1 generation
 *
 * This bit is set by software in order to generate an event, it is automatically cleared by hardware.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_EGR_CC1G_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Cleared = FieldValue<TIM3_EGR_CC1G_Values, 0U, BaseType>;
    /**
     * 1: A capture/compare event is generated on channel
     *
     * If channel CC1 is configured as output: CC1IF flag is set, Corresponding interrupt or DMA request is
     * sent if enabled.
     *
     * If channel CC1 is configured as input: The current value of the counter is captured in TIMx_CCR1 register.
     * The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled.
     * The CC1OF flag is set if the CC1IF flag was already high.
     */
    using Generate = FieldValue<TIM3_EGR_CC1G_Values, 1U, BaseType>;
};

/** Update generation */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_EGR_UG_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Cleared = FieldValue<TIM3_EGR_UG_Values, 0U, BaseType>;
    /**
     *  Re-initializes the timer counter and generates an update of the registers. Note that the
     *  prescaler counter is cleared too (but the prescaler ratio is not affected).
     */
    using ReInit = FieldValue<TIM3_EGR_UG_Values, 1U, BaseType>;
};

/**  Output compare clear enable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR1_Output_OC2CE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 0: OCxRef is not affected by the ETRF input
    using NotAffected = FieldValue<TIM3_CCMR1_Output_OC2CE_Values, 0U, BaseType>;
    // 1: OCxRef is cleared as soon as a High level is detected on ETRF input
    using Cleared = FieldValue<TIM3_CCMR1_Output_OC2CE_Values, 1U, BaseType>;
};

/**
 * Output compare mode
 *
 * These bits define the behavior of the output reference signal OCxREF from which OCx and
 * OCxN are derived. OCxREF is active high whereas OCx and OCxN active level depends
 * on CCxP and CCxNP bits.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR1_Output_OC2M_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /**
     * 000: Frozen - The comparison between the output compare register TIMx_CCRx and the
     * counter TIMx_CNT has no effect on the outputs.(this mode is used to generate a timing base).
     */
    using Frozen = FieldValue<TIM3_CCMR1_Output_OC2M_Values, 0U, BaseType>;
    /**
     * 001: Set channel 1 to active level on match. OCxREF signal is forced high when the counter
     * TIMx_CNT matches the capture/compare register 1 (TIMx_CCRx).
     */
    using ActiveLevelOnMatch = FieldValue<TIM3_CCMR1_Output_OC2M_Values, 1U, BaseType>;
    /**
     * 010: Set channel 1 to inactive level on match. OCxREF signal is forced low when the counter
     * TIMx_CNT matches the capture/compare register 1 (TIMx_CCRx).
     */
    using InactiveLevelOnMatch = FieldValue<TIM3_CCMR1_Output_OC2M_Values, 2U, BaseType>;
    // 011: Toggle - OCxREF toggles when TIMx_CNT=TIMx_CCRx.
    using Toggle = FieldValue<TIM3_CCMR1_Output_OC2M_Values, 3U, BaseType>;
    // 100: Force inactive level - OCxREF is forced low.
    using ForceInactive = FieldValue<TIM3_CCMR1_Output_OC2M_Values, 4U, BaseType>;
    // 101: Force active level - OCxREF is forced high.
    using ForceActive = FieldValue<TIM3_CCMR1_Output_OC2M_Values, 5U, BaseType>;
    /**
     * 110: PWM mode 1 - In upcounting, channel 1 is active as long as TIMx_CNT<TIMx_CCRx
     * else inactive. In downcounting, channel 1 is inactive (OCxREF=‘0) as long as
     * TIMx_CNT > TIMx_CCRx else active (OCxREF=1).
     */
    using PWM1 = FieldValue<TIM3_CCMR1_Output_OC2M_Values, 6U, BaseType>;
    /**
     * 111: PWM mode 2 - In upcounting, channel 1 is inactive as long as TIMx_CNT<TIMx_CCRx
     * else active. In downcounting, channel 1 is active as long as TIMx_CNT > TIMx_CCRx else inactive
     */
    using PWM2 = FieldValue<TIM3_CCMR1_Output_OC2M_Values, 7U, BaseType>;
};

/** Output compare preload enable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR1_Output_OC2PE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /**
     * 0: Preload register on TIMx_CCRx disabled. TIMx_CCRx can be written at anytime, the
     * new value is taken in account immediately
     */
    using Disable = FieldValue<TIM3_CCMR1_Output_OC2PE_Values, 0U, BaseType>;
    /**
     * 1: Preload register on TIMx_CCRx enabled. Read/Write operations access the preload
     * register. TIMx_CCRx preload value is loaded in the active register at each update event.
     */
    using Enable = FieldValue<TIM3_CCMR1_Output_OC2PE_Values, 1U, BaseType>;
};

/**
 * Output compare fast enable.
 * This bit is used to accelerate the effect of an event on the trigger in input on the CC output.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR1_Output_OC2FE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /**
     * 0: CCx behaves normally depending on the counter and CCRx values even when the
     * trigger is ON. The minimum delay to activate the CCx output when an edge occurs on the
     * trigger input is 5 clock cycles
     */
    using Disable = FieldValue<TIM3_CCMR1_Output_OC2FE_Values, 0U, BaseType>;
    /**
     * 1: An active edge on the trigger input acts like a compare match on the CCx output. Then,
     * OC is set to the compare level independently of the result of the comparison. Delay to
     * sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OC1FE
     * acts only if the channel is configured in PWM1 or PWM2 mode.
     */
    using Enable = FieldValue<TIM3_CCMR1_Output_OC2FE_Values, 1U, BaseType>;
};

/**
 * Capture/Compare selection.
 * This bitfield defines the direction of the channel (input/output) as well as the used input.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR1_Output_CC2S_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 00: CCx channel is configured as output
    using Output = FieldValue<TIM3_CCMR1_Output_CC2S_Values, 0U, BaseType>;
    // 01: CCx channel is configured as input, ICx is mapped on TI1
    using InputTI1 = FieldValue<TIM3_CCMR1_Output_CC2S_Values, 1U, BaseType>;
    // 10: CCx channel is configured as input, ICx is mapped on TI2
    using InputTI2 = FieldValue<TIM3_CCMR1_Output_CC2S_Values, 2U, BaseType>;
    /**
     * 11: CCx channel is configured as input, ICx is mapped on TRC. This mode is working only if
     * an internal trigger input is selected through TS bit (TIMx_SMCR register)
     */
    using InputTRC = FieldValue<TIM3_CCMR1_Output_CC2S_Values, 3U, BaseType>;
};

/**  Output compare clear enable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR1_Output_OC1CE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 0: OCxRef is not affected by the ETRF input
    using NotAffected = FieldValue<TIM3_CCMR1_Output_OC1CE_Values, 0U, BaseType>;
    // 1: OCxRef is cleared as soon as a High level is detected on ETRF input
    using Cleared = FieldValue<TIM3_CCMR1_Output_OC1CE_Values, 1U, BaseType>;
};

/**
 * Output compare mode
 *
 * These bits define the behavior of the output reference signal OCxREF from which OCx and
 * OCxN are derived. OCxREF is active high whereas OCx and OCxN active level depends
 * on CCxP and CCxNP bits.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR1_Output_OC1M_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /**
     * 000: Frozen - The comparison between the output compare register TIMx_CCRx and the
     * counter TIMx_CNT has no effect on the outputs.(this mode is used to generate a timing base).
     */
    using Frozen = FieldValue<TIM3_CCMR1_Output_OC1M_Values, 0U, BaseType>;
    /**
     * 001: Set channel 1 to active level on match. OCxREF signal is forced high when the counter
     * TIMx_CNT matches the capture/compare register 1 (TIMx_CCRx).
     */
    using ActiveLevelOnMatch = FieldValue<TIM3_CCMR1_Output_OC1M_Values, 1U, BaseType>;
    /**
     * 010: Set channel 1 to inactive level on match. OCxREF signal is forced low when the counter
     * TIMx_CNT matches the capture/compare register 1 (TIMx_CCRx).
     */
    using InactiveLevelOnMatch = FieldValue<TIM3_CCMR1_Output_OC1M_Values, 2U, BaseType>;
    // 011: Toggle - OCxREF toggles when TIMx_CNT=TIMx_CCRx.
    using Toggle = FieldValue<TIM3_CCMR1_Output_OC1M_Values, 3U, BaseType>;
    // 100: Force inactive level - OCxREF is forced low.
    using ForceInactive = FieldValue<TIM3_CCMR1_Output_OC1M_Values, 4U, BaseType>;
    // 101: Force active level - OCxREF is forced high.
    using ForceActive = FieldValue<TIM3_CCMR1_Output_OC1M_Values, 5U, BaseType>;
    /**
     * 110: PWM mode 1 - In upcounting, channel 1 is active as long as TIMx_CNT<TIMx_CCRx
     * else inactive. In downcounting, channel 1 is inactive (OCxREF=‘0) as long as
     * TIMx_CNT > TIMx_CCRx else active (OCxREF=1).
     */
    using PWM1 = FieldValue<TIM3_CCMR1_Output_OC1M_Values, 6U, BaseType>;
    /**
     * 111: PWM mode 2 - In upcounting, channel 1 is inactive as long as TIMx_CNT<TIMx_CCRx
     * else active. In downcounting, channel 1 is active as long as TIMx_CNT > TIMx_CCRx else inactive
     */
    using PWM2 = FieldValue<TIM3_CCMR1_Output_OC1M_Values, 7U, BaseType>;
};

/** Output compare preload enable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR1_Output_OC1PE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /**
     * 0: Preload register on TIMx_CCRx disabled. TIMx_CCRx can be written at anytime, the
     * new value is taken in account immediately
     */
    using Disable = FieldValue<TIM3_CCMR1_Output_OC1PE_Values, 0U, BaseType>;
    /**
     * 1: Preload register on TIMx_CCRx enabled. Read/Write operations access the preload
     * register. TIMx_CCRx preload value is loaded in the active register at each update event.
     */
    using Enable = FieldValue<TIM3_CCMR1_Output_OC1PE_Values, 1U, BaseType>;
};

/**
 * Output compare fast enable.
 * This bit is used to accelerate the effect of an event on the trigger in input on the CC output.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR1_Output_OC1FE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /**
      * 0: CCx behaves normally depending on the counter and CCRx values even when the
      * trigger is ON. The minimum delay to activate the CCx output when an edge occurs on the
      * trigger input is 5 clock cycles
      */
    using Disable = FieldValue<TIM3_CCMR1_Output_OC1FE_Values, 0U, BaseType>;
    /**
     * 1: An active edge on the trigger input acts like a compare match on the CCx output. Then,
     * OC is set to the compare level independently of the result of the comparison. Delay to
     * sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OC1FE
     * acts only if the channel is configured in PWM1 or PWM2 mode.
     */
    using Enable = FieldValue<TIM3_CCMR1_Output_OC1FE_Values, 1U, BaseType>;
};

/**
 * Capture/Compare selection.
 * This bitfield defines the direction of the channel (input/output) as well as the used input.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR1_Output_CC1S_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 00: CCx channel is configured as output
    using Output = FieldValue<TIM3_CCMR1_Output_CC1S_Values, 0U, BaseType>;
    // 01: CCx channel is configured as input, ICx is mapped on TI1
    using InputTI1 = FieldValue<TIM3_CCMR1_Output_CC1S_Values, 1U, BaseType>;
    // 10: CCx channel is configured as input, ICx is mapped on TI2
    using InputTI2 = FieldValue<TIM3_CCMR1_Output_CC1S_Values, 2U, BaseType>;
    /**
     * 11: CCx channel is configured as input, ICx is mapped on TRC. This mode is working only if
     * an internal trigger input is selected through TS bit (TIMx_SMCR register)
     */
    using InputTRC = FieldValue<TIM3_CCMR1_Output_CC1S_Values, 3U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR1_Input_IC2F_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 0000: No filter, sampling is done at fDTS
    using No = FieldValue<TIM3_CCMR1_Input_IC2F_Values, 0U, BaseType>;
    // 0001: fSAMPLING=fCK_INT, N=2
    using CKintDiv0N2 = FieldValue<TIM3_CCMR1_Input_IC2F_Values, 1U, BaseType>;
    // 0010: fSAMPLING=fCK_INT, N=4
    using CKintDiv0N4 = FieldValue<TIM3_CCMR1_Input_IC2F_Values, 2U, BaseType>;
    // 0011: fSAMPLING=fCK_INT, N=8
    using CKintDiv0N8 = FieldValue<TIM3_CCMR1_Input_IC2F_Values, 3U, BaseType>;
    // 0100: fSAMPLING=fDTS/2, N=6
    using CKintDiv2N6 = FieldValue<TIM3_CCMR1_Input_IC2F_Values, 4U, BaseType>;
    // 0101: fSAMPLING=fDTS/2, N=8
    using CKintDiv2N8 = FieldValue<TIM3_CCMR1_Input_IC2F_Values, 5U, BaseType>;
    // 0110: fSAMPLING=fDTS/4, N=6
    using CKintDiv4N6 = FieldValue<TIM3_CCMR1_Input_IC2F_Values, 6U, BaseType>;
    // 0111: fSAMPLING=fDTS/4, N=8
    using CKintDiv4N8 = FieldValue<TIM3_CCMR1_Input_IC2F_Values, 7U, BaseType>;
    // 1000: fSAMPLING=fDTS/8, N=6
    using CKintDiv8N6 = FieldValue<TIM3_CCMR1_Input_IC2F_Values, 8U, BaseType>;
    // 1001: fSAMPLING=fDTS/8, N=8
    using CKintDiv8N8 = FieldValue<TIM3_CCMR1_Input_IC2F_Values, 9U, BaseType>;
    // 1010: fSAMPLING=fDTS/16, N=5
    using CKintDiv16N5 = FieldValue<TIM3_CCMR1_Input_IC2F_Values, 10U, BaseType>;
    // 1011: fSAMPLING=fDTS/16, N=6
    using CKintDiv16N6 = FieldValue<TIM3_CCMR1_Input_IC2F_Values, 11U, BaseType>;
    // 1100: fSAMPLING=fDTS/16, N=8
    using CKintDiv16N8 = FieldValue<TIM3_CCMR1_Input_IC2F_Values, 12U, BaseType>;
    // 1101: fSAMPLING=fDTS/32, N=5
    using CKintDiv32N5 = FieldValue<TIM3_CCMR1_Input_IC2F_Values, 13U, BaseType>;
    // 1110: fSAMPLING=fDTS/32, N=6
    using CKintDiv32N6 = FieldValue<TIM3_CCMR1_Input_IC2F_Values, 14U, BaseType>;
    // 1111: fSAMPLING=fDTS/32, N=8
    using CKintDiv32N8 = FieldValue<TIM3_CCMR1_Input_IC2F_Values, 15U, BaseType>;
};

/**
 * Input capture 2 prescaler
 *
 * This bit-field defines the ratio of the prescaler acting on CCx input (ICx).
 * The prescaler is reset as soon as CCxE=0 (TIMx_CCER register).
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR1_Input_IC2PSC_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 00: no prescaler, capture is done each time an edge is detected on the capture input
    using NoPrescaler = FieldValue<TIM3_CCMR1_Input_IC2PSC_Values, 0U, BaseType>;
    // 01: capture is done once every 2 events
    using Every2Events = FieldValue<TIM3_CCMR1_Input_IC2PSC_Values, 1U, BaseType>;
    // 10: capture is done once every 4 events
    using Every4Events = FieldValue<TIM3_CCMR1_Input_IC2PSC_Values, 2U, BaseType>;
    // 11: capture is done once every 8 events
    using Every8Events = FieldValue<TIM3_CCMR1_Input_IC2PSC_Values, 3U, BaseType>;
};

/**
 * Capture/Compare 1 selection
 *
 * This bit-field defines the direction of the channel (input/output) as well as the used input.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR1_Input_CC2S_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 00: CCx channel is configured as output
    using Output = FieldValue<TIM3_CCMR1_Input_CC2S_Values, 0U, BaseType>;
    // 01: CCx channel is configured as input, ICx is mapped on TI1
    using InputTI1 = FieldValue<TIM3_CCMR1_Input_CC2S_Values, 1U, BaseType>;
    // 10: CCx channel is configured as input, ICx is mapped on TI2
    using InputTI2 = FieldValue<TIM3_CCMR1_Input_CC2S_Values, 2U, BaseType>;
    /**
     * 11: CCx channel is configured as input, ICx is mapped on TRC. This mode is working only if
     * an internal trigger input is selected through TS bit (TIMx_SMCR register)
     */
    using InputTRC = FieldValue<TIM3_CCMR1_Input_CC2S_Values, 3U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR1_Input_IC1F_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 0000: No filter, sampling is done at fDTS
    using No = FieldValue<TIM3_CCMR1_Input_IC1F_Values, 0U, BaseType>;
    // 0001: fSAMPLING=fCK_INT, N=2
    using CKintDiv0N2 = FieldValue<TIM3_CCMR1_Input_IC1F_Values, 1U, BaseType>;
    // 0010: fSAMPLING=fCK_INT, N=4
    using CKintDiv0N4 = FieldValue<TIM3_CCMR1_Input_IC1F_Values, 2U, BaseType>;
    // 0011: fSAMPLING=fCK_INT, N=8
    using CKintDiv0N8 = FieldValue<TIM3_CCMR1_Input_IC1F_Values, 3U, BaseType>;
    // 0100: fSAMPLING=fDTS/2, N=6
    using CKintDiv2N6 = FieldValue<TIM3_CCMR1_Input_IC1F_Values, 4U, BaseType>;
    // 0101: fSAMPLING=fDTS/2, N=8
    using CKintDiv2N8 = FieldValue<TIM3_CCMR1_Input_IC1F_Values, 5U, BaseType>;
    // 0110: fSAMPLING=fDTS/4, N=6
    using CKintDiv4N6 = FieldValue<TIM3_CCMR1_Input_IC1F_Values, 6U, BaseType>;
    // 0111: fSAMPLING=fDTS/4, N=8
    using CKintDiv4N8 = FieldValue<TIM3_CCMR1_Input_IC1F_Values, 7U, BaseType>;
    // 1000: fSAMPLING=fDTS/8, N=6
    using CKintDiv8N6 = FieldValue<TIM3_CCMR1_Input_IC1F_Values, 8U, BaseType>;
    // 1001: fSAMPLING=fDTS/8, N=8
    using CKintDiv8N8 = FieldValue<TIM3_CCMR1_Input_IC1F_Values, 9U, BaseType>;
    // 1010: fSAMPLING=fDTS/16, N=5
    using CKintDiv16N5 = FieldValue<TIM3_CCMR1_Input_IC1F_Values, 10U, BaseType>;
    // 1011: fSAMPLING=fDTS/16, N=6
    using CKintDiv16N6 = FieldValue<TIM3_CCMR1_Input_IC1F_Values, 11U, BaseType>;
    // 1100: fSAMPLING=fDTS/16, N=8
    using CKintDiv16N8 = FieldValue<TIM3_CCMR1_Input_IC1F_Values, 12U, BaseType>;
    // 1101: fSAMPLING=fDTS/32, N=5
    using CKintDiv32N5 = FieldValue<TIM3_CCMR1_Input_IC1F_Values, 13U, BaseType>;
    // 1110: fSAMPLING=fDTS/32, N=6
    using CKintDiv32N6 = FieldValue<TIM3_CCMR1_Input_IC1F_Values, 14U, BaseType>;
    // 1111: fSAMPLING=fDTS/32, N=8
    using CKintDiv32N8 = FieldValue<TIM3_CCMR1_Input_IC1F_Values, 15U, BaseType>;
};

/**
 * Input capture 1 prescaler
 *
 * This bit-field defines the ratio of the prescaler acting on CCx input (ICx).
 * The prescaler is reset as soon as CCxE=0 (TIMx_CCER register).
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR1_Input_IC1PSC_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 00: no prescaler, capture is done each time an edge is detected on the capture input
    using NoPrescaler = FieldValue<TIM3_CCMR1_Input_IC1PSC_Values, 0U, BaseType>;
    // 01: capture is done once every 2 events
    using Every2Events = FieldValue<TIM3_CCMR1_Input_IC1PSC_Values, 1U, BaseType>;
    // 10: capture is done once every 4 events
    using Every4Events = FieldValue<TIM3_CCMR1_Input_IC1PSC_Values, 2U, BaseType>;
    // 11: capture is done once every 8 events
    using Every8Events = FieldValue<TIM3_CCMR1_Input_IC1PSC_Values, 3U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR1_Input_CC1S_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 00: CCx channel is configured as output
    using Output = FieldValue<TIM3_CCMR1_Input_CC1S_Values, 0U, BaseType>;
    // 01: CCx channel is configured as input, ICx is mapped on TI1
    using InputTI1 = FieldValue<TIM3_CCMR1_Input_CC1S_Values, 1U, BaseType>;
    // 10: CCx channel is configured as input, ICx is mapped on TI2
    using InputTI2 = FieldValue<TIM3_CCMR1_Input_CC1S_Values, 2U, BaseType>;
    /**
     * 11: CCx channel is configured as input, ICx is mapped on TRC. This mode is working only if
     * an internal trigger input is selected through TS bit (TIMx_SMCR register)
     */
    using InputTRC = FieldValue<TIM3_CCMR1_Input_CC1S_Values, 3U, BaseType>;
};

/**  Output compare clear enable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR2_Output_OC4CE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 0: OCxRef is not affected by the ETRF input
    using NotAffected = FieldValue<TIM3_CCMR2_Output_OC4CE_Values, 0U, BaseType>;
    // 1: OCxRef is cleared as soon as a High level is detected on ETRF input
    using Cleared = FieldValue<TIM3_CCMR2_Output_OC4CE_Values, 1U, BaseType>;
};

/**
 * Output compare mode
 *
 * These bits define the behavior of the output reference signal OCxREF from which OCx and
 * OCxN are derived. OCxREF is active high whereas OCx and OCxN active level depends
 * on CCxP and CCxNP bits.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR2_Output_OC4M_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /**
     * 000: Frozen - The comparison between the output compare register TIMx_CCRx and the
     * counter TIMx_CNT has no effect on the outputs.(this mode is used to generate a timing base).
     */
    using Frozen = FieldValue<TIM3_CCMR2_Output_OC4M_Values, 0U, BaseType>;
    /**
     * 001: Set channel 1 to active level on match. OCxREF signal is forced high when the counter
     * TIMx_CNT matches the capture/compare register 1 (TIMx_CCRx).
     */
    using ActiveLevelOnMatch = FieldValue<TIM3_CCMR2_Output_OC4M_Values, 1U, BaseType>;
    /**
     * 010: Set channel 1 to inactive level on match. OCxREF signal is forced low when the counter
     * TIMx_CNT matches the capture/compare register 1 (TIMx_CCRx).
     */
    using InactiveLevelOnMatch = FieldValue<TIM3_CCMR2_Output_OC4M_Values, 2U, BaseType>;
    // 011: Toggle - OCxREF toggles when TIMx_CNT=TIMx_CCRx.
    using Toggle = FieldValue<TIM3_CCMR2_Output_OC4M_Values, 3U, BaseType>;
    // 100: Force inactive level - OCxREF is forced low.
    using ForceInactive = FieldValue<TIM3_CCMR2_Output_OC4M_Values, 4U, BaseType>;
    // 101: Force active level - OCxREF is forced high.
    using ForceActive = FieldValue<TIM3_CCMR2_Output_OC4M_Values, 5U, BaseType>;
    /**
     * 110: PWM mode 1 - In upcounting, channel 1 is active as long as TIMx_CNT<TIMx_CCRx
     * else inactive. In downcounting, channel 1 is inactive (OCxREF=‘0) as long as
     * TIMx_CNT > TIMx_CCRx else active (OCxREF=1).
     */
    using PWM1 = FieldValue<TIM3_CCMR2_Output_OC4M_Values, 6U, BaseType>;
    /**
     * 111: PWM mode 2 - In upcounting, channel 1 is inactive as long as TIMx_CNT<TIMx_CCRx
     * else active. In downcounting, channel 1 is active as long as TIMx_CNT > TIMx_CCRx else inactive
     */
    using PWM2 = FieldValue<TIM3_CCMR2_Output_OC4M_Values, 7U, BaseType>;
};

/** Output compare preload enable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR2_Output_OC4PE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /**
     * 0: Preload register on TIMx_CCRx disabled. TIMx_CCRx can be written at anytime, the
     * new value is taken in account immediately
     */
    using Disable = FieldValue<TIM3_CCMR2_Output_OC4PE_Values, 0U, BaseType>;
    /**
     * 1: Preload register on TIMx_CCRx enabled. Read/Write operations access the preload
     * register. TIMx_CCRx preload value is loaded in the active register at each update event.
     */
    using Enable = FieldValue<TIM3_CCMR2_Output_OC4PE_Values, 1U, BaseType>;
};

/**
 * Output compare fast enable.
 * This bit is used to accelerate the effect of an event on the trigger in input on the CC output.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR2_Output_OC4FE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /**
     * 0: CCx behaves normally depending on the counter and CCRx values even when the
     * trigger is ON. The minimum delay to activate the CCx output when an edge occurs on the
     * trigger input is 5 clock cycles
     */
    using Disable = FieldValue<TIM3_CCMR2_Output_OC4FE_Values, 0U, BaseType>;
    /**
     * 1: An active edge on the trigger input acts like a compare match on the CCx output. Then,
     * OC is set to the compare level independently of the result of the comparison. Delay to
     * sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OC1FE
     * acts only if the channel is configured in PWM1 or PWM2 mode.
     */
    using Enable = FieldValue<TIM3_CCMR2_Output_OC4FE_Values, 1U, BaseType>;
};

/**
 * Capture/Compare selection.
 * This bitfield defines the direction of the channel (input/output) as well as the used input.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR2_Output_CC4S_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 00: CCx channel is configured as output
    using Output = FieldValue<TIM3_CCMR2_Output_CC4S_Values, 0U, BaseType>;
    // 01: CCx channel is configured as input, ICx is mapped on TI1
    using InputTI1 = FieldValue<TIM3_CCMR2_Output_CC4S_Values, 1U, BaseType>;
    // 10: CCx channel is configured as input, ICx is mapped on TI2
    using InputTI2 = FieldValue<TIM3_CCMR2_Output_CC4S_Values, 2U, BaseType>;
    /**
     * 11: CCx channel is configured as input, ICx is mapped on TRC. This mode is working only if
     * an internal trigger input is selected through TS bit (TIMx_SMCR register)
     */
    using InputTRC = FieldValue<TIM3_CCMR2_Output_CC4S_Values, 3U, BaseType>;
};

/**  Output compare clear enable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR2_Output_OC3CE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 0: OCxRef is not affected by the ETRF input
    using NotAffected = FieldValue<TIM3_CCMR2_Output_OC3CE_Values, 0U, BaseType>;
    // 1: OCxRef is cleared as soon as a High level is detected on ETRF input
    using Cleared = FieldValue<TIM3_CCMR2_Output_OC3CE_Values, 1U, BaseType>;
};

/**
 * Output compare mode
 *
 * These bits define the behavior of the output reference signal OCxREF from which OCx and
 * OCxN are derived. OCxREF is active high whereas OCx and OCxN active level depends
 * on CCxP and CCxNP bits.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR2_Output_OC3M_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /**
     * 000: Frozen - The comparison between the output compare register TIMx_CCRx and the
     * counter TIMx_CNT has no effect on the outputs.(this mode is used to generate a timing base).
     */
    using Frozen = FieldValue<TIM3_CCMR2_Output_OC3M_Values, 0U, BaseType>;
    /**
     * 001: Set channel 1 to active level on match. OCxREF signal is forced high when the counter
     * TIMx_CNT matches the capture/compare register 1 (TIMx_CCRx).
     */
    using ActiveLevelOnMatch = FieldValue<TIM3_CCMR2_Output_OC3M_Values, 1U, BaseType>;
    /**
     * 010: Set channel 1 to inactive level on match. OCxREF signal is forced low when the counter
     * TIMx_CNT matches the capture/compare register 1 (TIMx_CCRx).
     */
    using InactiveLevelOnMatch = FieldValue<TIM3_CCMR2_Output_OC3M_Values, 2U, BaseType>;
    // 011: Toggle - OCxREF toggles when TIMx_CNT=TIMx_CCRx.
    using Toggle = FieldValue<TIM3_CCMR2_Output_OC3M_Values, 3U, BaseType>;
    // 100: Force inactive level - OCxREF is forced low.
    using ForceInactive = FieldValue<TIM3_CCMR2_Output_OC3M_Values, 4U, BaseType>;
    // 101: Force active level - OCxREF is forced high.
    using ForceActive = FieldValue<TIM3_CCMR2_Output_OC3M_Values, 5U, BaseType>;
    /**
     * 110: PWM mode 1 - In upcounting, channel 1 is active as long as TIMx_CNT<TIMx_CCRx
     * else inactive. In downcounting, channel 1 is inactive (OCxREF=‘0) as long as
     * TIMx_CNT > TIMx_CCRx else active (OCxREF=1).
     */
    using PWM1 = FieldValue<TIM3_CCMR2_Output_OC3M_Values, 6U, BaseType>;
    /**
     * 111: PWM mode 2 - In upcounting, channel 1 is inactive as long as TIMx_CNT<TIMx_CCRx
     * else active. In downcounting, channel 1 is active as long as TIMx_CNT > TIMx_CCRx else inactive
     */
    using PWM2 = FieldValue<TIM3_CCMR2_Output_OC3M_Values, 7U, BaseType>;
};

/** Output compare preload enable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR2_Output_OC3PE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /**
     * 0: Preload register on TIMx_CCRx disabled. TIMx_CCRx can be written at anytime, the
     * new value is taken in account immediately
     */
    using Disable = FieldValue<TIM3_CCMR2_Output_OC3PE_Values, 0U, BaseType>;
    /**
     * 1: Preload register on TIMx_CCRx enabled. Read/Write operations access the preload
     * register. TIMx_CCRx preload value is loaded in the active register at each update event.
     */
    using Enable = FieldValue<TIM3_CCMR2_Output_OC3PE_Values, 1U, BaseType>;
};

/**
 * Output compare fast enable.
 * This bit is used to accelerate the effect of an event on the trigger in input on the CC output.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR2_Output_OC3FE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /**
     * 0: CCx behaves normally depending on the counter and CCRx values even when the
     * trigger is ON. The minimum delay to activate the CCx output when an edge occurs on the
     * trigger input is 5 clock cycles
     */
    using Disable = FieldValue<TIM3_CCMR2_Output_OC3FE_Values, 0U, BaseType>;
    /**
     * 1: An active edge on the trigger input acts like a compare match on the CCx output. Then,
     * OC is set to the compare level independently of the result of the comparison. Delay to
     * sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OC1FE
     * acts only if the channel is configured in PWM1 or PWM2 mode.
     */
    using Enable = FieldValue<TIM3_CCMR2_Output_OC3FE_Values, 1U, BaseType>;
};

/**
 * Capture/Compare selection.
 * This bitfield defines the direction of the channel (input/output) as well as the used input.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR2_Output_CC3S_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 00: CCx channel is configured as output
    using Output = FieldValue<TIM3_CCMR2_Output_CC3S_Values, 0U, BaseType>;
    // 01: CCx channel is configured as input, ICx is mapped on TI1
    using InputTI1 = FieldValue<TIM3_CCMR2_Output_CC3S_Values, 1U, BaseType>;
    // 10: CCx channel is configured as input, ICx is mapped on TI2
    using InputTI2 = FieldValue<TIM3_CCMR2_Output_CC3S_Values, 2U, BaseType>;
    /**
     * 11: CCx channel is configured as input, ICx is mapped on TRC. This mode is working only if
     * an internal trigger input is selected through TS bit (TIMx_SMCR register)
     */
    using InputTRC = FieldValue<TIM3_CCMR2_Output_CC3S_Values, 3U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR2_Input_IC4F_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 0000: No filter, sampling is done at fDTS
    using No = FieldValue<TIM3_CCMR2_Input_IC4F_Values, 0U, BaseType>;
    // 0001: fSAMPLING=fCK_INT, N=2
    using CKintDiv0N2 = FieldValue<TIM3_CCMR2_Input_IC4F_Values, 1U, BaseType>;
    // 0010: fSAMPLING=fCK_INT, N=4
    using CKintDiv0N4 = FieldValue<TIM3_CCMR2_Input_IC4F_Values, 2U, BaseType>;
    // 0011: fSAMPLING=fCK_INT, N=8
    using CKintDiv0N8 = FieldValue<TIM3_CCMR2_Input_IC4F_Values, 3U, BaseType>;
    // 0100: fSAMPLING=fDTS/2, N=6
    using CKintDiv2N6 = FieldValue<TIM3_CCMR2_Input_IC4F_Values, 4U, BaseType>;
    // 0101: fSAMPLING=fDTS/2, N=8
    using CKintDiv2N8 = FieldValue<TIM3_CCMR2_Input_IC4F_Values, 5U, BaseType>;
    // 0110: fSAMPLING=fDTS/4, N=6
    using CKintDiv4N6 = FieldValue<TIM3_CCMR2_Input_IC4F_Values, 6U, BaseType>;
    // 0111: fSAMPLING=fDTS/4, N=8
    using CKintDiv4N8 = FieldValue<TIM3_CCMR2_Input_IC4F_Values, 7U, BaseType>;
    // 1000: fSAMPLING=fDTS/8, N=6
    using CKintDiv8N6 = FieldValue<TIM3_CCMR2_Input_IC4F_Values, 8U, BaseType>;
    // 1001: fSAMPLING=fDTS/8, N=8
    using CKintDiv8N8 = FieldValue<TIM3_CCMR2_Input_IC4F_Values, 9U, BaseType>;
    // 1010: fSAMPLING=fDTS/16, N=5
    using CKintDiv16N5 = FieldValue<TIM3_CCMR2_Input_IC4F_Values, 10U, BaseType>;
    // 1011: fSAMPLING=fDTS/16, N=6
    using CKintDiv16N6 = FieldValue<TIM3_CCMR2_Input_IC4F_Values, 11U, BaseType>;
    // 1100: fSAMPLING=fDTS/16, N=8
    using CKintDiv16N8 = FieldValue<TIM3_CCMR2_Input_IC4F_Values, 12U, BaseType>;
    // 1101: fSAMPLING=fDTS/32, N=5
    using CKintDiv32N5 = FieldValue<TIM3_CCMR2_Input_IC4F_Values, 13U, BaseType>;
    // 1110: fSAMPLING=fDTS/32, N=6
    using CKintDiv32N6 = FieldValue<TIM3_CCMR2_Input_IC4F_Values, 14U, BaseType>;
    // 1111: fSAMPLING=fDTS/32, N=8
    using CKintDiv32N8 = FieldValue<TIM3_CCMR2_Input_IC4F_Values, 15U, BaseType>;
};

/**
 * Input capture 4 prescaler
 *
 * This bit-field defines the ratio of the prescaler acting on CCx input (ICx).
 * The prescaler is reset as soon as CCxE=0 (TIMx_CCER register).
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR2_Input_IC4PSC_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 00: no prescaler, capture is done each time an edge is detected on the capture input
    using NoPrescaler = FieldValue<TIM3_CCMR2_Input_IC4PSC_Values, 0U, BaseType>;
    // 01: capture is done once every 2 events
    using Every2Events = FieldValue<TIM3_CCMR2_Input_IC4PSC_Values, 1U, BaseType>;
    // 10: capture is done once every 4 events
    using Every4Events = FieldValue<TIM3_CCMR2_Input_IC4PSC_Values, 2U, BaseType>;
    // 11: capture is done once every 8 events
    using Every8Events = FieldValue<TIM3_CCMR2_Input_IC4PSC_Values, 3U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR2_Input_CC4S_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 00: CCx channel is configured as output
    using Output = FieldValue<TIM3_CCMR2_Input_CC4S_Values, 0U, BaseType>;
    // 01: CCx channel is configured as input, ICx is mapped on TI1
    using InputTI1 = FieldValue<TIM3_CCMR2_Input_CC4S_Values, 1U, BaseType>;
    // 10: CCx channel is configured as input, ICx is mapped on TI2
    using InputTI2 = FieldValue<TIM3_CCMR2_Input_CC4S_Values, 2U, BaseType>;
    /**
     * 11: CCx channel is configured as input, ICx is mapped on TRC. This mode is working only if
     * an internal trigger input is selected through TS bit (TIMx_SMCR register)
     */
    using InputTRC = FieldValue<TIM3_CCMR2_Input_CC4S_Values, 3U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR2_Input_IC3F_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 0000: No filter, sampling is done at fDTS
    using No = FieldValue<TIM3_CCMR2_Input_IC3F_Values, 0U, BaseType>;
    // 0001: fSAMPLING=fCK_INT, N=2
    using CKintDiv0N2 = FieldValue<TIM3_CCMR2_Input_IC3F_Values, 1U, BaseType>;
    // 0010: fSAMPLING=fCK_INT, N=4
    using CKintDiv0N4 = FieldValue<TIM3_CCMR2_Input_IC3F_Values, 2U, BaseType>;
    // 0011: fSAMPLING=fCK_INT, N=8
    using CKintDiv0N8 = FieldValue<TIM3_CCMR2_Input_IC3F_Values, 3U, BaseType>;
    // 0100: fSAMPLING=fDTS/2, N=6
    using CKintDiv2N6 = FieldValue<TIM3_CCMR2_Input_IC3F_Values, 4U, BaseType>;
    // 0101: fSAMPLING=fDTS/2, N=8
    using CKintDiv2N8 = FieldValue<TIM3_CCMR2_Input_IC3F_Values, 5U, BaseType>;
    // 0110: fSAMPLING=fDTS/4, N=6
    using CKintDiv4N6 = FieldValue<TIM3_CCMR2_Input_IC3F_Values, 6U, BaseType>;
    // 0111: fSAMPLING=fDTS/4, N=8
    using CKintDiv4N8 = FieldValue<TIM3_CCMR2_Input_IC3F_Values, 7U, BaseType>;
    // 1000: fSAMPLING=fDTS/8, N=6
    using CKintDiv8N6 = FieldValue<TIM3_CCMR2_Input_IC3F_Values, 8U, BaseType>;
    // 1001: fSAMPLING=fDTS/8, N=8
    using CKintDiv8N8 = FieldValue<TIM3_CCMR2_Input_IC3F_Values, 9U, BaseType>;
    // 1010: fSAMPLING=fDTS/16, N=5
    using CKintDiv16N5 = FieldValue<TIM3_CCMR2_Input_IC3F_Values, 10U, BaseType>;
    // 1011: fSAMPLING=fDTS/16, N=6
    using CKintDiv16N6 = FieldValue<TIM3_CCMR2_Input_IC3F_Values, 11U, BaseType>;
    // 1100: fSAMPLING=fDTS/16, N=8
    using CKintDiv16N8 = FieldValue<TIM3_CCMR2_Input_IC3F_Values, 12U, BaseType>;
    // 1101: fSAMPLING=fDTS/32, N=5
    using CKintDiv32N5 = FieldValue<TIM3_CCMR2_Input_IC3F_Values, 13U, BaseType>;
    // 1110: fSAMPLING=fDTS/32, N=6
    using CKintDiv32N6 = FieldValue<TIM3_CCMR2_Input_IC3F_Values, 14U, BaseType>;
    // 1111: fSAMPLING=fDTS/32, N=8
    using CKintDiv32N8 = FieldValue<TIM3_CCMR2_Input_IC3F_Values, 15U, BaseType>;
};

/**
 * Input capture 3 prescaler
 *
 * This bit-field defines the ratio of the prescaler acting on CCx input (ICx).
 * The prescaler is reset as soon as CCxE=0 (TIMx_CCER register).
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR2_Input_IC3PSC_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 00: no prescaler, capture is done each time an edge is detected on the capture input
    using NoPrescaler = FieldValue<TIM3_CCMR2_Input_IC3PSC_Values, 0U, BaseType>;
    // 01: capture is done once every 2 events
    using Every2Events = FieldValue<TIM3_CCMR2_Input_IC3PSC_Values, 1U, BaseType>;
    // 10: capture is done once every 4 events
    using Every4Events = FieldValue<TIM3_CCMR2_Input_IC3PSC_Values, 2U, BaseType>;
    // 11: capture is done once every 8 events
    using Every8Events = FieldValue<TIM3_CCMR2_Input_IC3PSC_Values, 3U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR2_Input_CC3S_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 00: CCx channel is configured as output
    using Output = FieldValue<TIM3_CCMR2_Input_CC3S_Values, 0U, BaseType>;
    // 01: CCx channel is configured as input, ICx is mapped on TI1
    using InputTI1 = FieldValue<TIM3_CCMR2_Input_CC3S_Values, 1U, BaseType>;
    // 10: CCx channel is configured as input, ICx is mapped on TI2
    using InputTI2 = FieldValue<TIM3_CCMR2_Input_CC3S_Values, 2U, BaseType>;
    /**
     * 11: CCx channel is configured as input, ICx is mapped on TRC. This mode is working only if
     * an internal trigger input is selected through TS bit (TIMx_SMCR register)
     */
    using InputTRC = FieldValue<TIM3_CCMR2_Input_CC3S_Values, 3U, BaseType>;
};

/**
 * Capture/Compare 4 output Polarity
 *
 * Refer to CC1NP description
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCER_CC4NP_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /**
     * CCx channel configured as output: CC1NP must be kept cleared in this case.
     */
    
    using Cleared = FieldValue<TIM3_CCER_CC4NP_Values, 0U, BaseType>;
    
    /**
     * CCCx channel configured as input:
     * This bit is used in conjunction with CC1P to define TI1FP1/TI2FP1 polarity. refer to CC1P description.
     */
    
    /**
     * 00: noninverted/rising edge. Circuit is sensitive to TIxFP1 rising edge
     * (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted
     * (trigger in gated mode, encoder mode).
     */
    using Rising = FieldValue<TIM3_CCER_CC4NP_Values, 0U, BaseType>;
    /**
     * 01: inverted/falling edge Circuit is sensitive to TIxFP1 falling edge
     * (capture, trigger in reset, external clock or trigger mode),
     * TIxFP1 is inverted (trigger in gated mode, encoder mode).
     */
    using Falling = FieldValue<TIM3_CCER_CC4NP_Values, 1U, BaseType>;
    /**
     * 11: noninverted/both edges. Circuit is sensitive to both TIxFP1 rising and falling edges
     * (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted
     * (trigger in gated mode). This configuration must not be used for encoder mode.
     */
    using Both = FieldValue<TIM3_CCER_CC4NP_Values, 1U, BaseType>;
};

/**
 * Capture/Compare 4 output Polarity.
 *
 * refer to CC1P description
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCER_CC4P_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /** CCx channel configured as output */
    // 0: OCx active high
    using High = FieldValue<TIM3_CCER_CC4P_Values, 0U, BaseType>;
    // 1: OCx active low
    using Low = FieldValue<TIM3_CCER_CC4P_Values, 1U, BaseType>;
    
    /**
     * CCx channel configured as input
     * CC1NP/CC1P bits select TI1FP1 and TI2FP1 polarity for trigger or capture operations.
     */
    
    /**
     * 00: noninverted/rising edge. Circuit is sensitive to TIxFP1 rising edge
     * (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted
     * (trigger in gated mode, encoder mode).
     */
    using Rising = FieldValue<TIM3_CCER_CC4P_Values, 0U, BaseType>;
    /**
     * 01: inverted/falling edge Circuit is sensitive to TIxFP1 falling edge
     * (capture, trigger in reset, external clock or trigger mode),
     * TIxFP1 is inverted (trigger in gated mode, encoder mode).
     */
    using Falling = FieldValue<TIM3_CCER_CC4P_Values, 1U, BaseType>;
    /**
     * 11: noninverted/both edges. Circuit is sensitive to both TIxFP1 rising and falling edges
     * (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted
     * (trigger in gated mode). This configuration must not be used for encoder mode.
     */
    using Both = FieldValue<TIM3_CCER_CC4P_Values, 1U, BaseType>;
};

/**
 * Capture/Compare output enable.
 *
 * CCx channel configured as output:
 *   0: Off - OC1 is not active
 *   1: On - OC1 signal is output on the corresponding output pin
 * CC1 channel configured as input:
 * This bit determines if a capture of the counter value can actually be done into the input
 *  capture/compare register 1 (TIMx_CCRx) or not.
 *   0: Capture disabled
 *   1: Capture enabled
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCER_CC4E_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Disable = FieldValue<TIM3_CCER_CC4E_Values, 0U, BaseType>;
    using Enable = FieldValue<TIM3_CCER_CC4E_Values, 1U, BaseType>;
};

/**
 * Capture/Compare 3 output Polarity
 *
 * Refer to CC1NP description
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCER_CC3NP_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /**
     * CCx channel configured as output: CC1NP must be kept cleared in this case.
     */
    
    using Cleared = FieldValue<TIM3_CCER_CC3NP_Values, 0U, BaseType>;
    
    /**
     * CCCx channel configured as input:
     * This bit is used in conjunction with CC1P to define TI1FP1/TI2FP1 polarity. refer to CC1P description.
     */
    
    /**
     * 00: noninverted/rising edge. Circuit is sensitive to TIxFP1 rising edge
     * (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted
     * (trigger in gated mode, encoder mode).
     */
    using Rising = FieldValue<TIM3_CCER_CC3NP_Values, 0U, BaseType>;
    /**
     * 01: inverted/falling edge Circuit is sensitive to TIxFP1 falling edge
     * (capture, trigger in reset, external clock or trigger mode),
     * TIxFP1 is inverted (trigger in gated mode, encoder mode).
     */
    using Falling = FieldValue<TIM3_CCER_CC3NP_Values, 1U, BaseType>;
    /**
     * 11: noninverted/both edges. Circuit is sensitive to both TIxFP1 rising and falling edges
     * (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted
     * (trigger in gated mode). This configuration must not be used for encoder mode.
     */
    using Both = FieldValue<TIM3_CCER_CC3NP_Values, 1U, BaseType>;
};

/**
 * Capture/Compare 3 output Polarity.
 *
 * refer to CC1P description
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCER_CC3P_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /** CCx channel configured as output */
    // 0: OCx active high
    using High = FieldValue<TIM3_CCER_CC3P_Values, 0U, BaseType>;
    // 1: OCx active low
    using Low = FieldValue<TIM3_CCER_CC3P_Values, 1U, BaseType>;
    
    /**
     * CCx channel configured as input
     * CC1NP/CC1P bits select TI1FP1 and TI2FP1 polarity for trigger or capture operations.
     */
    
    /**
     * 00: noninverted/rising edge. Circuit is sensitive to TIxFP1 rising edge
     * (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted
     * (trigger in gated mode, encoder mode).
     */
    using Rising = FieldValue<TIM3_CCER_CC3P_Values, 0U, BaseType>;
    /**
     * 01: inverted/falling edge Circuit is sensitive to TIxFP1 falling edge
     * (capture, trigger in reset, external clock or trigger mode),
     * TIxFP1 is inverted (trigger in gated mode, encoder mode).
     */
    using Falling = FieldValue<TIM3_CCER_CC3P_Values, 1U, BaseType>;
    /**
     * 11: noninverted/both edges. Circuit is sensitive to both TIxFP1 rising and falling edges
     * (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted
     * (trigger in gated mode). This configuration must not be used for encoder mode.
     */
    using Both = FieldValue<TIM3_CCER_CC3P_Values, 1U, BaseType>;
};
/**
 * Capture/Compare output enable.
 *
 * CCx channel configured as output:
 *   0: Off - OC1 is not active
 *   1: On - OC1 signal is output on the corresponding output pin
 * CC1 channel configured as input:
 * This bit determines if a capture of the counter value can actually be done into the input
 *  capture/compare register 1 (TIMx_CCRx) or not.
 *   0: Capture disabled
 *   1: Capture enabled
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCER_CC3E_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Disable = FieldValue<TIM3_CCER_CC3E_Values, 0U, BaseType>;
    using Enable = FieldValue<TIM3_CCER_CC3E_Values, 1U, BaseType>;
};

/**
 * Capture/Compare 2 output Polarity
 *
 * Refer to CC1NP description
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCER_CC2NP_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /**
     * CCx channel configured as output: CC1NP must be kept cleared in this case.
     */
    
    using Cleared = FieldValue<TIM3_CCER_CC2NP_Values, 0U, BaseType>;
    
    /**
     * CCCx channel configured as input:
     * This bit is used in conjunction with CC1P to define TI1FP1/TI2FP1 polarity. refer to CC1P description.
     */
    
    /**
     * 00: noninverted/rising edge. Circuit is sensitive to TIxFP1 rising edge
     * (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted
     * (trigger in gated mode, encoder mode).
     */
    using Rising = FieldValue<TIM3_CCER_CC2NP_Values, 0U, BaseType>;
    /**
     * 01: inverted/falling edge Circuit is sensitive to TIxFP1 falling edge
     * (capture, trigger in reset, external clock or trigger mode),
     * TIxFP1 is inverted (trigger in gated mode, encoder mode).
     */
    using Falling = FieldValue<TIM3_CCER_CC2NP_Values, 1U, BaseType>;
    /**
     * 11: noninverted/both edges. Circuit is sensitive to both TIxFP1 rising and falling edges
     * (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted
     * (trigger in gated mode). This configuration must not be used for encoder mode.
     */
    using Both = FieldValue<TIM3_CCER_CC2NP_Values, 1U, BaseType>;
};

/**
 * Capture/Compare 2 output Polarity.
 *
 * refer to CC1P description
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCER_CC2P_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /** CCx channel configured as output */
    // 0: OCx active high
    using High = FieldValue<TIM3_CCER_CC2P_Values, 0U, BaseType>;
    // 1: OCx active low
    using Low = FieldValue<TIM3_CCER_CC2P_Values, 1U, BaseType>;
    
    /**
     * CCx channel configured as input
     * CC1NP/CC1P bits select TI1FP1 and TI2FP1 polarity for trigger or capture operations.
     */
    
    /**
     * 00: noninverted/rising edge. Circuit is sensitive to TIxFP1 rising edge
     * (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted
     * (trigger in gated mode, encoder mode).
     */
    using Rising = FieldValue<TIM3_CCER_CC2P_Values, 0U, BaseType>;
    /**
     * 01: inverted/falling edge Circuit is sensitive to TIxFP1 falling edge
     * (capture, trigger in reset, external clock or trigger mode),
     * TIxFP1 is inverted (trigger in gated mode, encoder mode).
     */
    using Falling = FieldValue<TIM3_CCER_CC2P_Values, 1U, BaseType>;
    /**
     * 11: noninverted/both edges. Circuit is sensitive to both TIxFP1 rising and falling edges
     * (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted
     * (trigger in gated mode). This configuration must not be used for encoder mode.
     */
    using Both = FieldValue<TIM3_CCER_CC2P_Values, 1U, BaseType>;
};

/**
 * Capture/Compare output enable.
 *
 * CCx channel configured as output:
 *   0: Off - OC1 is not active
 *   1: On - OC1 signal is output on the corresponding output pin
 * CC1 channel configured as input:
 * This bit determines if a capture of the counter value can actually be done into the input
 *  capture/compare register 1 (TIMx_CCRx) or not.
 *   0: Capture disabled
 *   1: Capture enabled
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCER_CC2E_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Disable = FieldValue<TIM3_CCER_CC2E_Values, 0U, BaseType>;
    using Enable = FieldValue<TIM3_CCER_CC2E_Values, 1U, BaseType>;
};

/**
 * Capture/Compare 1 output Polarity
 *
 * Refer to CC1NP description
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCER_CC1NP_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /**
     * CCx channel configured as output: CC1NP must be kept cleared in this case.
     */
    
    using Cleared = FieldValue<TIM3_CCER_CC1NP_Values, 0U, BaseType>;
    
    /**
     * CCCx channel configured as input:
     * This bit is used in conjunction with CC1P to define TI1FP1/TI2FP1 polarity. refer to CC1P description.
     */
    
    /**
     * 00: noninverted/rising edge. Circuit is sensitive to TIxFP1 rising edge
     * (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted
     * (trigger in gated mode, encoder mode).
     */
    using Rising = FieldValue<TIM3_CCER_CC1NP_Values, 0U, BaseType>;
    /**
     * 01: inverted/falling edge Circuit is sensitive to TIxFP1 falling edge
     * (capture, trigger in reset, external clock or trigger mode),
     * TIxFP1 is inverted (trigger in gated mode, encoder mode).
     */
    using Falling = FieldValue<TIM3_CCER_CC1NP_Values, 1U, BaseType>;
    /**
     * 11: noninverted/both edges. Circuit is sensitive to both TIxFP1 rising and falling edges
     * (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted
     * (trigger in gated mode). This configuration must not be used for encoder mode.
     */
    using Both = FieldValue<TIM3_CCER_CC1NP_Values, 1U, BaseType>;
};

/**
 * Capture/Compare 1 output Polarity.
 *
 * refer to CC1P description
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCER_CC1P_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /** CCx channel configured as output */
    // 0: OCx active high
    using High = FieldValue<TIM3_CCER_CC1P_Values, 0U, BaseType>;
    // 1: OCx active low
    using Low = FieldValue<TIM3_CCER_CC1P_Values, 1U, BaseType>;
    
    /**
     * CCx channel configured as input
     * CC1NP/CC1P bits select TI1FP1 and TI2FP1 polarity for trigger or capture operations.
     */
     
    /**
     * 00: noninverted/rising edge. Circuit is sensitive to TIxFP1 rising edge
     * (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted
     * (trigger in gated mode, encoder mode).
     */
    using Rising = FieldValue<TIM3_CCER_CC1P_Values, 0U, BaseType>;
    /**
     * 01: inverted/falling edge Circuit is sensitive to TIxFP1 falling edge
     * (capture, trigger in reset, external clock or trigger mode),
     * TIxFP1 is inverted (trigger in gated mode, encoder mode).
     */
    using Falling = FieldValue<TIM3_CCER_CC1P_Values, 1U, BaseType>;
    /**
     * 11: noninverted/both edges. Circuit is sensitive to both TIxFP1 rising and falling edges
     * (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted
     * (trigger in gated mode). This configuration must not be used for encoder mode.
     */
    using Both = FieldValue<TIM3_CCER_CC1P_Values, 1U, BaseType>;
};

/**
 * Capture/Compare output enable.
 *
 * CCx channel configured as output:
 *   0: Off - OC1 is not active
 *   1: On - OC1 signal is output on the corresponding output pin
 * CC1 channel configured as input:
 * This bit determines if a capture of the counter value can actually be done into the input
 *  capture/compare register 1 (TIMx_CCRx) or not.
 *   0: Capture disabled
 *   1: Capture enabled
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCER_CC1E_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Disable = FieldValue<TIM3_CCER_CC1E_Values, 0U, BaseType>;
    using Enable = FieldValue<TIM3_CCER_CC1E_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CNT_CNT_Values : public RegisterField<Reg, offset, size, AccessMode> {};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_PSC_PSC_Values : public RegisterField<Reg, offset, size, AccessMode> {};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_ARR_ARR_Values : public RegisterField<Reg, offset, size, AccessMode> {};

/**
 * Capture/Compare 1 value
 *
 * If channel CC1 is configured as output:
 *
 * CCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).
 * It is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC1PE).
 * Else the preload value is copied in the active capture/compare 1 register when an update event occurs.
 *
 * The active capture/compare register contains the value to be compared to the counter
 * TIMx_CNT and signaled on OC1 output.
 *
 * If channel CC1 is configured as input:
 * CCR1 is the counter value transferred by the last input capture 1 event (IC1).
 * The TIMx_CCR1 register is read-only and cannot be programmed.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCR1_CCR1_Values : public RegisterField<Reg, offset, size, AccessMode> {};

/**
 * Capture/Compare 2 value
 *
 * Refer to CCR1 description
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCR2_CCR2_Values : public RegisterField<Reg, offset, size, AccessMode> {};

/**
 * Capture/Compare 3 value
 *
 * Refer to CCR1 description
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCR3_CCR1_Values : public RegisterField<Reg, offset, size, AccessMode> {};

/**
 * Capture/Compare 4 value
 *
 * Refer to CCR1 description
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCR4_CCR4_Values : public RegisterField<Reg, offset, size, AccessMode> {};

/**
 * DMA burst length
 *
 * This 5-bit vector defines the number of DMA transfers (the timer recognizes a burst transfer
 * when a read or a write access is done to the TIMx_DMAR address).
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_DCR_DBL_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 00000: 1 transfer
    using Length1 = FieldValue<TIM3_DCR_DBL_Values, 0U, BaseType>;
    // 00001: 2 transfers
    using Length2 = FieldValue<TIM3_DCR_DBL_Values, 1U, BaseType>;
    // 00010: 3 transfers
    using Length3 = FieldValue<TIM3_DCR_DBL_Values, 2U, BaseType>;
    // 00011: 4 transfers
    using Length4 = FieldValue<TIM3_DCR_DBL_Values, 3U, BaseType>;
    // 00100: 5 transfers
    using Length5 = FieldValue<TIM3_DCR_DBL_Values, 4U, BaseType>;
    // 00101: 6 transfers
    using Length6 = FieldValue<TIM3_DCR_DBL_Values, 5U, BaseType>;
    // 00110: 7 transfers
    using Length7 = FieldValue<TIM3_DCR_DBL_Values, 6U, BaseType>;
    // 00111: 8 transfers
    using Length8 = FieldValue<TIM3_DCR_DBL_Values, 7U, BaseType>;
    // 01000: 9 transfers
    using Length9 = FieldValue<TIM3_DCR_DBL_Values, 8U, BaseType>;
    // 01001: 10 transfers
    using Length10 = FieldValue<TIM3_DCR_DBL_Values, 9U, BaseType>;
    // 01010: 11 transfers
    using Length11 = FieldValue<TIM3_DCR_DBL_Values, 10U, BaseType>;
    // 01011: 12 transfers
    using Length12 = FieldValue<TIM3_DCR_DBL_Values, 11U, BaseType>;
    // 01100: 13 transfers
    using Length13 = FieldValue<TIM3_DCR_DBL_Values, 12U, BaseType>;
    // 01101: 14 transfers
    using Length14 = FieldValue<TIM3_DCR_DBL_Values, 13U, BaseType>;
    // 01110: 15 transfers
    using Length15 = FieldValue<TIM3_DCR_DBL_Values, 14U, BaseType>;
    // 01111: 16 transfers
    using Length16 = FieldValue<TIM3_DCR_DBL_Values, 15U, BaseType>;
    // 10000: 17 transfers
    using Length17 = FieldValue<TIM3_DCR_DBL_Values, 16U, BaseType>;
    // 10001: 18 transfers
    using Length18 = FieldValue<TIM3_DCR_DBL_Values, 17U, BaseType>;
};

/**
 * DMA base addres
 *
 * This 5-bit vector defines the base-address for DMA transfers (when read/write access are
 * done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_DCR_DBA_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using CR1 = FieldValue<TIM3_DCR_DBA_Values, 0U, BaseType>;
    using CR2 = FieldValue<TIM3_DCR_DBA_Values, 1U, BaseType>;
    using SMCR = FieldValue<TIM3_DCR_DBA_Values, 2U, BaseType>;
    using DIER = FieldValue<TIM3_DCR_DBA_Values, 3U, BaseType>;
    using SR = FieldValue<TIM3_DCR_DBA_Values, 4U, BaseType>;
    using EGR = FieldValue<TIM3_DCR_DBA_Values, 5U, BaseType>;
    using CCMR1 = FieldValue<TIM3_DCR_DBA_Values, 6U, BaseType>;
    using CCMR2 = FieldValue<TIM3_DCR_DBA_Values, 7U, BaseType>;
    using CCER = FieldValue<TIM3_DCR_DBA_Values, 8U, BaseType>;
    using CNT = FieldValue<TIM3_DCR_DBA_Values, 9U, BaseType>;
    using PSC = FieldValue<TIM3_DCR_DBA_Values, 10U, BaseType>;
    using ARR = FieldValue<TIM3_DCR_DBA_Values, 11U, BaseType>;
    using Reserved1 = FieldValue<TIM3_DCR_DBA_Values, 12U, BaseType>;
    using CCR1 = FieldValue<TIM3_DCR_DBA_Values, 13U, BaseType>;
    using CCR2 = FieldValue<TIM3_DCR_DBA_Values, 14U, BaseType>;
    using CCR3 = FieldValue<TIM3_DCR_DBA_Values, 15U, BaseType>;
    using CCR4 = FieldValue<TIM3_DCR_DBA_Values, 16U, BaseType>;
};

/**
 * DMA register for burst accesses
 *
 * A read or write operation to the DMAR register accesses the register located at the address
 *       (TIMx_CR1 address) + (DBA + DMA index) x 4
 * where TIMx_CR1 address is the address of the control register 1, DBA is the DMA base
 * address configured in TIMx_DCR register, DMA index is automatically controlled by the
 * DMA transfer, and ranges from 0 to DBL (DBL configured in TIMx_DCR)
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_DMAR_DMAB_Values : public RegisterField<Reg, offset, size, AccessMode> {};