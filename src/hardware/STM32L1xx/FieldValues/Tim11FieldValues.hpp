/*******************************************************************************
* Filename      : Tim11FieldValues.hpp
*
* Details       : Enumerations related with TIM11 peripheral. This header file
*                 is auto-generated for STM32L152 device.
*
*
*******************************************************************************/

#pragma once

#include <register/FieldValue.hpp>

using namespace ng;

/**
 * Clock division
 *
 * This bit-field indicates the division ratio between the timer clock (CK_INT) frequency and
 * sampling clock used by the digital filters (ETR, TIx),
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM11_CR1_CKD_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 00: tDTS = tCK_INT
    using ClockInt = FieldValue<TIM11_CR1_CKD_Values, 0U, BaseType>;
    // 01: tDTS = 2 × tCK_INT
    using ClockIntMul2 = FieldValue<TIM11_CR1_CKD_Values, 1U, BaseType>;
    // 10: tDTS = 4 × tCK_INT
    using ClockIntMul4 = FieldValue<TIM11_CR1_CKD_Values, 2U, BaseType>;
};

/** Auto-reload preload enable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM11_CR1_ARPE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // register is not buffered
    using NotBuffered = FieldValue<TIM11_CR1_ARPE_Values, 0U, BaseType>;
    // register is buffered
    using Buffered = FieldValue<TIM11_CR1_ARPE_Values, 1U, BaseType>;
};

/** One-pulse mode */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM11_CR1_OPM_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // Counter is not stopped at update event
    using Disable = FieldValue<TIM11_CR1_OPM_Values, 0U, BaseType>;
    // Counter stops counting at the next update event (clearing the CEN bit).
    using Enable = FieldValue<TIM11_CR1_OPM_Values, 1U, BaseType>;
};

/**
 * Update request source
 *
 * This bit is set and cleared by software to select the UEV event sources.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM11_CR1_URS_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /**
     * 0: Any of the following events generates an update interrupt or DMA request if enabled.
     * These events can be:
     *   – Counter overflow/underflow
     *   – Setting the UG bit
     *   – Update generation through the slave mode controller
     */
    using AllEvents = FieldValue<TIM11_CR1_URS_Values, 0U, BaseType>;
    /** 1: Only counter overflow/underflow generates an update interrupt or DMA request if enabled. */
    using CounterOverflow = FieldValue<TIM11_CR1_URS_Values, 1U, BaseType>;
};

/** Update disable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM11_CR1_UDIS_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /**
     * 0: UEV enabled. The Update (UEV) event is generated by one of the following events:
     *
     *   – Counter overflow/underflow
     *   – Setting the UG bit
     *   – Update generation through the slave mode controller
     *
     * Buffered registers are then loaded with their preload values.
     */
    using UEVEnabled = FieldValue<TIM11_CR1_UDIS_Values, 0U, BaseType>;
    /**
     * 1: UEV disabled. The Update event is not generated, shadow registers keep their value
     * (ARR, PSC). However the counter and the prescaler are reinitialized if the UG bit is set or if
     * a hardware reset is received from the slave mode controller.
     */
    using UEVDisabled = FieldValue<TIM11_CR1_UDIS_Values, 1U, BaseType>;
};

/** Counter enable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM11_CR1_CEN_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Disable = FieldValue<TIM11_CR1_CEN_Values, 0U, BaseType>;
    using Enable = FieldValue<TIM11_CR1_CEN_Values, 1U, BaseType>;
};

/**
 * External trigger polarity
 *
 * This bit selects whether ETR or ETR is used for trigger operations
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM11_SMCR_ETP_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 0: ETR is non-inverted, active at high level or rising edge
    using NonInverted = FieldValue<TIM11_SMCR_ETP_Values, 0U, BaseType>;
    // 1: ETR is inverted, active at low level or falling edge
    using Inverted = FieldValue<TIM11_SMCR_ETP_Values, 1U, BaseType>;
};

/**
 * External clock enable
 *
 * This bit enables External clock mode 2
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM11_SMCR_ECE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 0: External clock mode 2 disabled
    using Disable = FieldValue<TIM11_SMCR_ECE_Values, 0U, BaseType>;
    /**
     * External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.
     * 1: Setting the ECE bit has the same effect as selecting external clock mode 1 with TRGI
     *    connected to ETRF (SMS=111 and TS=111).
     * 2: It is possible to simultaneously use external clock mode 2 with the following slave modes: reset mode,
     *    gated mode and trigger mode. Nevertheless, TRGI must not be connected to ETRF in this case
     *    (TS bits must not be 111).
     * 3: If external clock mode 1 and external clock mode 2 are enabled at the same time, the external
     *    clock input is ETRF.
     */
    using Enable = FieldValue<TIM11_SMCR_ECE_Values, 1U, BaseType>;
};

/**
 * External trigger prescaler
 *
 * External trigger signal ETRP frequency must be at most 1/4 of CK_INT frequency. A prescaler can be enabled
 * to reduce ETRP frequency. It is useful when inputting fast external clocks.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM11_SMCR_ETPS_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 00: Prescaler OFF
    using Off = FieldValue<TIM11_SMCR_ETPS_Values, 0U, BaseType>;
    // 01: ETRP frequency divided by 2
    using DivBy2 = FieldValue<TIM11_SMCR_ETPS_Values, 1U, BaseType>;
    // 10: ETRP frequency divided by 4
    using DivBy4 = FieldValue<TIM11_SMCR_ETPS_Values, 2U, BaseType>;
    // 11: ETRP frequency divided by 8
    using DivBy8 = FieldValue<TIM11_SMCR_ETPS_Values, 3U, BaseType>;
};

/**
 * External trigger filter
 *
 * This bit-field then defines the frequency used to sample ETRP signal and the length of the
 * digital filter applied to ETRP. The digital filter is made of an event counter in which N
 * consecutive events are needed to validate a transition on the output:
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM11_SMCR_ETF_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 0000: No filter, sampling is done at fDTS
    using No = FieldValue<TIM11_SMCR_ETF_Values, 0U, BaseType>;
    // 0001: fSAMPLING=fCK_INT, N=2
    using CKintDiv0N2 = FieldValue<TIM11_SMCR_ETF_Values, 1U, BaseType>;
    // 0010: fSAMPLING=fCK_INT, N=4
    using CKintDiv0N4 = FieldValue<TIM11_SMCR_ETF_Values, 2U, BaseType>;
    // 0011: fSAMPLING=fCK_INT, N=8
    using CKintDiv0N8 = FieldValue<TIM11_SMCR_ETF_Values, 3U, BaseType>;
    // 0100: fSAMPLING=fDTS/2, N=6
    using CKintDiv2N6 = FieldValue<TIM11_SMCR_ETF_Values, 4U, BaseType>;
    // 0101: fSAMPLING=fDTS/2, N=8
    using CKintDiv2N8 = FieldValue<TIM11_SMCR_ETF_Values, 5U, BaseType>;
    // 0110: fSAMPLING=fDTS/4, N=6
    using CKintDiv4N6 = FieldValue<TIM11_SMCR_ETF_Values, 6U, BaseType>;
    // 0111: fSAMPLING=fDTS/4, N=8
    using CKintDiv4N8 = FieldValue<TIM11_SMCR_ETF_Values, 7U, BaseType>;
    // 1000: fSAMPLING=fDTS/8, N=6
    using CKintDiv8N6 = FieldValue<TIM11_SMCR_ETF_Values, 8U, BaseType>;
    // 1001: fSAMPLING=fDTS/8, N=8
    using CKintDiv8N8 = FieldValue<TIM11_SMCR_ETF_Values, 9U, BaseType>;
    // 1010: fSAMPLING=fDTS/16, N=5
    using CKintDiv16N5 = FieldValue<TIM11_SMCR_ETF_Values, 10U, BaseType>;
    // 1011: fSAMPLING=fDTS/16, N=6
    using CKintDiv16N6 = FieldValue<TIM11_SMCR_ETF_Values, 11U, BaseType>;
    // 1100: fSAMPLING=fDTS/16, N=8
    using CKintDiv16N8 = FieldValue<TIM11_SMCR_ETF_Values, 12U, BaseType>;
    // 1101: fSAMPLING=fDTS/32, N=5
    using CKintDiv32N5 = FieldValue<TIM11_SMCR_ETF_Values, 13U, BaseType>;
    // 1110: fSAMPLING=fDTS/32, N=6
    using CKintDiv32N6 = FieldValue<TIM11_SMCR_ETF_Values, 14U, BaseType>;
    // 1111: fSAMPLING=fDTS/32, N=8
    using CKintDiv32N8 = FieldValue<TIM11_SMCR_ETF_Values, 15U, BaseType>;
};

/** Capture/Compare 1 interrupt enable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM11_DIER_CC1IE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Disable = FieldValue<TIM11_DIER_CC1IE_Values, 0U, BaseType>;
    using Enable = FieldValue<TIM11_DIER_CC1IE_Values, 1U, BaseType>;
};

/** Update interrupt enable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM11_DIER_UIE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Disable = FieldValue<TIM11_DIER_UIE_Values, 0U, BaseType>;
    using Enable = FieldValue<TIM11_DIER_UIE_Values, 1U, BaseType>;
};

/**
 * Capture/Compare 1 overcapture flag
 *
 * This flag is set by hardware only when the corresponding channel is configured in input capture mode.
 * It is cleared by software by writing it to ‘0.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM11_SR_CC1OF_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 0: No overcapture has been detected
    using Cleared = FieldValue<TIM11_SR_CC1OF_Values, 0U, BaseType>;
    // 1: The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set
    using Updated = FieldValue<TIM11_SR_CC1OF_Values, 1U, BaseType>;
};

/**
 * Capture/Compare 1 interrupt flag
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM11_SR_CC1IF_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /**
     * If channel CC1 is configured as output:
     *
     * This flag is set by hardware when the counter matches the compare value, with some
     * exception in center-aligned mode (refer to the CMS bits in the TIMx_CR1 register description).
     * It is cleared by software.
     *
     * 0: No match
     *
     * If channel CC1 is configured as input: this bit is set by hardware on a capture.
     * It is cleared by software or by reading the TIMx_CCR1 register.
     *
     * 0: No input capture occurred
     */
    using Cleared = FieldValue<TIM11_SR_CC1IF_Values, 0U, BaseType>;
    
    /**
     * If channel CC1 is configured as output:
     *
     * This flag is set by hardware when the counter matches the compare value, with some
     * exception in center-aligned mode (refer to the CMS bits in the TIMx_CR1 register description).
     * It is cleared by software.
     *
     * 1: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the contents of
     * TIMx_CCR1 are greater than the contents of TIMx_ARR, the CC1IF bit goes high on the counter overflow
     * (in upcounting and up/down-counting modes) or underflow (in downcounting mode)
     *
     * If channel CC1 is configured as input: this bit is set by hardware on a capture.
     * It is cleared by software or by reading the TIMx_CCR1 register.
     *
     * 1: The counter value has been captured in TIMx_CCR1 register (An edge has been detected on IC1 which
     * matches the selected polarity)
     */
    using Updated = FieldValue<TIM11_SR_CC1IF_Values, 1U, BaseType>;
};

/**
 * Update interrupt flag.
 * This bit is set by hardware on an update event. It is cleared by software.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM11_SR_UIF_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // No update occurred.
    using Cleared = FieldValue<TIM11_SR_UIF_Values, 0U, BaseType>;
    /**
     * Update interrupt pending. This bit is set by hardware when the registers are updated:
     *   – At overflow or underflow and if UDIS = 0 in the TIMx_CR1 register.
     *   – When CNT is reinitialized by software using the UG bit in the TIMx_EGR register, if URS = 0
     *     and UDIS = 0 in the TIMx_CR1 register.
     */
    using Updated = FieldValue<TIM11_SR_UIF_Values, 1U, BaseType>;
};

/**
 * Capture/compare 1 generation
 *
 * This bit is set by software in order to generate an event, it is automatically cleared by hardware.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM11_EGR_CC1G_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Cleared = FieldValue<TIM11_EGR_CC1G_Values, 0U, BaseType>;
    /**
     * 1: A capture/compare event is generated on channel
     *
     * If channel CC1 is configured as output: CC1IF flag is set, Corresponding interrupt or DMA request is
     * sent if enabled.
     *
     * If channel CC1 is configured as input: The current value of the counter is captured in TIMx_CCR1 register.
     * The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled.
     * The CC1OF flag is set if the CC1IF flag was already high.
     */
    using Generate = FieldValue<TIM11_EGR_CC1G_Values, 1U, BaseType>;
};

/** Update generation */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM11_EGR_UG_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Cleared = FieldValue<TIM11_EGR_UG_Values, 0U, BaseType>;
    /**
     *  Re-initializes the timer counter and generates an update of the registers. Note that the
     *  prescaler counter is cleared too (but the prescaler ratio is not affected).
     */
    using ReInit = FieldValue<TIM11_EGR_UG_Values, 1U, BaseType>;
};

/**  Output compare clear enable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM11_CCMR1_Output_OC1CE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 0: OCxRef is not affected by the ETRF input
    using NotAffected = FieldValue<TIM11_CCMR1_Output_OC1CE_Values, 0U, BaseType>;
    // 1: OCxRef is cleared as soon as a High level is detected on ETRF input
    using Cleared = FieldValue<TIM11_CCMR1_Output_OC1CE_Values, 1U, BaseType>;
};

/**
 * Output compare mode
 *
 * These bits define the behavior of the output reference signal OCxREF from which OCx and
 * OCxN are derived. OCxREF is active high whereas OCx and OCxN active level depends
 * on CCxP and CCxNP bits.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM11_CCMR1_Output_OC1M_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /**
     * 000: Frozen - The comparison between the output compare register TIMx_CCRx and the
     * counter TIMx_CNT has no effect on the outputs.(this mode is used to generate a timing base).
     */
    using Frozen = FieldValue<TIM11_CCMR1_Output_OC1M_Values, 0U, BaseType>;
    /**
     * 001: Set channel 1 to active level on match. OCxREF signal is forced high when the counter
     * TIMx_CNT matches the capture/compare register 1 (TIMx_CCRx).
     */
    using ActiveLevelOnMatch = FieldValue<TIM11_CCMR1_Output_OC1M_Values, 1U, BaseType>;
    /**
     * 010: Set channel 1 to inactive level on match. OCxREF signal is forced low when the counter
     * TIMx_CNT matches the capture/compare register 1 (TIMx_CCRx).
     */
    using InactiveLevelOnMatch = FieldValue<TIM11_CCMR1_Output_OC1M_Values, 2U, BaseType>;
    // 011: Toggle - OCxREF toggles when TIMx_CNT=TIMx_CCRx.
    using Toggle = FieldValue<TIM11_CCMR1_Output_OC1M_Values, 3U, BaseType>;
    // 100: Force inactive level - OCxREF is forced low.
    using ForceInactive = FieldValue<TIM11_CCMR1_Output_OC1M_Values, 4U, BaseType>;
    // 101: Force active level - OCxREF is forced high.
    using ForceActive = FieldValue<TIM11_CCMR1_Output_OC1M_Values, 5U, BaseType>;
    /**
     * 110: PWM mode 1 - In upcounting, channel 1 is active as long as TIMx_CNT<TIMx_CCRx
     * else inactive. In downcounting, channel 1 is inactive (OCxREF=‘0) as long as
     * TIMx_CNT > TIMx_CCRx else active (OCxREF=1).
     */
    using PWM1 = FieldValue<TIM11_CCMR1_Output_OC1M_Values, 6U, BaseType>;
    /**
     * 111: PWM mode 2 - In upcounting, channel 1 is inactive as long as TIMx_CNT<TIMx_CCRx
     * else active. In downcounting, channel 1 is active as long as TIMx_CNT > TIMx_CCRx else inactive
     */
    using PWM2 = FieldValue<TIM11_CCMR1_Output_OC1M_Values, 7U, BaseType>;
};

/** Output compare preload enable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM11_CCMR1_Output_OC1PE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /**
     * 0: Preload register on TIMx_CCRx disabled. TIMx_CCRx can be written at anytime, the
     * new value is taken in account immediately
     */
    using Disable = FieldValue<TIM11_CCMR1_Output_OC1PE_Values, 0U, BaseType>;
    /**
     * 1: Preload register on TIMx_CCRx enabled. Read/Write operations access the preload
     * register. TIMx_CCRx preload value is loaded in the active register at each update event.
     */
    using Enable = FieldValue<TIM11_CCMR1_Output_OC1PE_Values, 1U, BaseType>;
};

/**
 * Output compare fast enable.
 * This bit is used to accelerate the effect of an event on the trigger in input on the CC output.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM11_CCMR1_Output_OC1FE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /**
      * 0: CCx behaves normally depending on the counter and CCRx values even when the
      * trigger is ON. The minimum delay to activate the CCx output when an edge occurs on the
      * trigger input is 5 clock cycles
      */
    using Disable = FieldValue<TIM11_CCMR1_Output_OC1FE_Values, 0U, BaseType>;
    /**
     * 1: An active edge on the trigger input acts like a compare match on the CCx output. Then,
     * OC is set to the compare level independently of the result of the comparison. Delay to
     * sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OC1FE
     * acts only if the channel is configured in PWM1 or PWM2 mode.
     */
    using Enable = FieldValue<TIM11_CCMR1_Output_OC1FE_Values, 1U, BaseType>;
};

/**
 * Capture/Compare selection.
 * This bitfield defines the direction of the channel (input/output) as well as the used input.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM11_CCMR1_Output_CC1S_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 00: CCx channel is configured as output
    using Output = FieldValue<TIM11_CCMR1_Output_CC1S_Values, 0U, BaseType>;
    // 01: CCx channel is configured as input, ICx is mapped on TI1
    using InputTI1 = FieldValue<TIM11_CCMR1_Output_CC1S_Values, 1U, BaseType>;
    // 10: CCx channel is configured as input, ICx is mapped on TI2
    using InputTI2 = FieldValue<TIM11_CCMR1_Output_CC1S_Values, 2U, BaseType>;
    /**
     * 11: CCx channel is configured as input, ICx is mapped on TRC. This mode is working only if
     * an internal trigger input is selected through TS bit (TIMx_SMCR register)
     */
    using InputTRC = FieldValue<TIM11_CCMR1_Output_CC1S_Values, 3U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM11_CCMR1_Input_IC1F_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 0000: No filter, sampling is done at fDTS
    using No = FieldValue<TIM11_CCMR1_Input_IC1F_Values, 0U, BaseType>;
    // 0001: fSAMPLING=fCK_INT, N=2
    using CKintDiv0N2 = FieldValue<TIM11_CCMR1_Input_IC1F_Values, 1U, BaseType>;
    // 0010: fSAMPLING=fCK_INT, N=4
    using CKintDiv0N4 = FieldValue<TIM11_CCMR1_Input_IC1F_Values, 2U, BaseType>;
    // 0011: fSAMPLING=fCK_INT, N=8
    using CKintDiv0N8 = FieldValue<TIM11_CCMR1_Input_IC1F_Values, 3U, BaseType>;
    // 0100: fSAMPLING=fDTS/2, N=6
    using CKintDiv2N6 = FieldValue<TIM11_CCMR1_Input_IC1F_Values, 4U, BaseType>;
    // 0101: fSAMPLING=fDTS/2, N=8
    using CKintDiv2N8 = FieldValue<TIM11_CCMR1_Input_IC1F_Values, 5U, BaseType>;
    // 0110: fSAMPLING=fDTS/4, N=6
    using CKintDiv4N6 = FieldValue<TIM11_CCMR1_Input_IC1F_Values, 6U, BaseType>;
    // 0111: fSAMPLING=fDTS/4, N=8
    using CKintDiv4N8 = FieldValue<TIM11_CCMR1_Input_IC1F_Values, 7U, BaseType>;
    // 1000: fSAMPLING=fDTS/8, N=6
    using CKintDiv8N6 = FieldValue<TIM11_CCMR1_Input_IC1F_Values, 8U, BaseType>;
    // 1001: fSAMPLING=fDTS/8, N=8
    using CKintDiv8N8 = FieldValue<TIM11_CCMR1_Input_IC1F_Values, 9U, BaseType>;
    // 1010: fSAMPLING=fDTS/16, N=5
    using CKintDiv16N5 = FieldValue<TIM11_CCMR1_Input_IC1F_Values, 10U, BaseType>;
    // 1011: fSAMPLING=fDTS/16, N=6
    using CKintDiv16N6 = FieldValue<TIM11_CCMR1_Input_IC1F_Values, 11U, BaseType>;
    // 1100: fSAMPLING=fDTS/16, N=8
    using CKintDiv16N8 = FieldValue<TIM11_CCMR1_Input_IC1F_Values, 12U, BaseType>;
    // 1101: fSAMPLING=fDTS/32, N=5
    using CKintDiv32N5 = FieldValue<TIM11_CCMR1_Input_IC1F_Values, 13U, BaseType>;
    // 1110: fSAMPLING=fDTS/32, N=6
    using CKintDiv32N6 = FieldValue<TIM11_CCMR1_Input_IC1F_Values, 14U, BaseType>;
    // 1111: fSAMPLING=fDTS/32, N=8
    using CKintDiv32N8 = FieldValue<TIM11_CCMR1_Input_IC1F_Values, 15U, BaseType>;
};

/**
 * Input capture 1 prescaler
 *
 * This bit-field defines the ratio of the prescaler acting on CCx input (ICx).
 * The prescaler is reset as soon as CCxE=0 (TIMx_CCER register).
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM11_CCMR1_Input_IC1PSC_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 00: no prescaler, capture is done each time an edge is detected on the capture input
    using NoPrescaler = FieldValue<TIM11_CCMR1_Input_IC1PSC_Values, 0U, BaseType>;
    // 01: capture is done once every 2 events
    using Every2Events = FieldValue<TIM11_CCMR1_Input_IC1PSC_Values, 1U, BaseType>;
    // 10: capture is done once every 4 events
    using Every4Events = FieldValue<TIM11_CCMR1_Input_IC1PSC_Values, 2U, BaseType>;
    // 11: capture is done once every 8 events
    using Every8Events = FieldValue<TIM11_CCMR1_Input_IC1PSC_Values, 3U, BaseType>;
};

/** Capture/Compare 1 selection */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM11_CCMR1_Input_CC1S_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 00: CCx channel is configured as output
    using Output = FieldValue<TIM11_CCMR1_Input_CC1S_Values, 0U, BaseType>;
    // 01: CCx channel is configured as input, ICx is mapped on TI1
    using InputTI1 = FieldValue<TIM11_CCMR1_Input_CC1S_Values, 1U, BaseType>;
};

/** Capture/Compare 1 output Polarity */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM11_CCER_CC1NP_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /**
     * CCx channel configured as output: CC1NP must be kept cleared in this case.
     */
    using Cleared = FieldValue<TIM11_CCER_CC1NP_Values, 0U, BaseType>;
    
    /**
     * CCCx channel configured as input:
     * CC1NP bit is used in conjunction with CC1P to define TI1FP1 polarity (refer to CC1P description).
     */
    
    /**
     * 00: noninverted/rising edge. Circuit is sensitive to TIxFP1 rising edge
     * (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted
     * (trigger in gated mode, encoder mode).
     */
    using Rising = FieldValue<TIM11_CCER_CC1NP_Values, 0U, BaseType>;
    /**
     * 01: inverted/falling edge Circuit is sensitive to TIxFP1 falling edge
     * (capture, trigger in reset, external clock or trigger mode),
     * TIxFP1 is inverted (trigger in gated mode, encoder mode).
     */
    using Falling = FieldValue<TIM11_CCER_CC1NP_Values, 1U, BaseType>;
};

/** Capture/Compare 1 output Polarity. */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM11_CCER_CC1P_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /** CCx channel configured as output */
    // 0: OCx active high
    using High = FieldValue<TIM11_CCER_CC1P_Values, 0U, BaseType>;
    // 1: OCx active low
    using Low = FieldValue<TIM11_CCER_CC1P_Values, 1U, BaseType>;
    
    /**
     * CCx channel configured as input
     * CCxNP/CCxP bits select TIxFP1 and TIxFP1 polarity for trigger or capture operations.
     */
    
    /**
     * 00: noninverted/rising edge. Circuit is sensitive to TIxFP1 rising edge
     * (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted
     * (trigger in gated mode, encoder mode).
     */
    using Rising = FieldValue<TIM11_CCER_CC1P_Values, 0U, BaseType>;
    /**
     * 01: inverted/falling edge Circuit is sensitive to TIxFP1 falling edge
     * (capture, trigger in reset, external clock or trigger mode),
     * TIxFP1 is inverted (trigger in gated mode, encoder mode).
     */
    using Falling = FieldValue<TIM11_CCER_CC1P_Values, 1U, BaseType>;
};

/**
 * Capture/Compare output enable.
 *
 * CCx channel configured as output:
 *   0: Off - OC1 is not active
 *   1: On - OC1 signal is output on the corresponding output pin
 * CC1 channel configured as input:
 * This bit determines if a capture of the counter value can actually be done into the input
 *  capture/compare register 1 (TIMx_CCRx) or not.
 *   0: Capture disabled
 *   1: Capture enabled
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM11_CCER_CC1E_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Disable = FieldValue<TIM11_CCER_CC1E_Values, 0U, BaseType>;
    using Enable = FieldValue<TIM11_CCER_CC1E_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM11_CNT_CNT_Values : public RegisterField<Reg, offset, size, AccessMode> {};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM11_PSC_PSC_Values : public RegisterField<Reg, offset, size, AccessMode> {};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM11_ARR_ARR_Values : public RegisterField<Reg, offset, size, AccessMode> {};

/**
 * Capture/Compare 1 value
 *
 * If channel CC1 is configured as output:
 *
 * CCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).
 * It is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC1PE).
 * Else the preload value is copied in the active capture/compare 1 register when an update event occurs.
 *
 * The active capture/compare register contains the value to be compared to the counter
 * TIMx_CNT and signaled on OC1 output.
 *
 * If channel CC1 is configured as input:
 * CCR1 is the counter value transferred by the last input capture 1 event (IC1).
 * The TIMx_CCR1 register is read-only and cannot be programmed.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM11_CCR1_CCR1_Values : public RegisterField<Reg, offset, size, AccessMode> {};

/**
 * Timer11 Input 1 remap for Routing Interface (RI)
 *
 * Set and cleared by software.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM11_OR_TI1_RMP_RI_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 0: Channel1 connection depends on TI1_RMP[1:0] bit values (see below)
    using TI1_RMP = FieldValue<TIM11_OR_TI1_RMP_RI_Values, 0U, BaseType>;
    // 1: Channel1 is connected to RI (whatever the value of the TI1_RMP bits).
    using ConnectedToRI = FieldValue<TIM11_OR_TI1_RMP_RI_Values, 1U, BaseType>;
};

/**
 * Timer11 ETR remap
 *
 * Set and cleared by software.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM11_OR_ETR_RMP_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 0: ETR input is connected to LSE clock
    using Value0 = FieldValue<TIM11_OR_ETR_RMP_Values, 0U, BaseType>;
    // 1: ETR input is connected to TIM9_TRGO
    using Value1 = FieldValue<TIM11_OR_ETR_RMP_Values, 1U, BaseType>;
};

/**
 * TIM11 Input 1 remapping capability
 *
 * Set and cleared by software.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM11_OR_TI1_RMP_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /**
     * 00: TIM11 Channel1 is connected to the GPIO (refer to the Alternate function
     *     mapping table in the datasheets).
     */
    using AltFn = FieldValue<TIM11_OR_TI1_RMP_Values, 0U, BaseType>;
    // 01: MSI internal clock is connected to the TIM11_CH1 input for measurement purposes
    using MSI = FieldValue<TIM11_OR_TI1_RMP_Values, 1U, BaseType>;
    // 10: HSE_RTC clock (HSE divided by programmable prescaler) is connected to the
    using HSE = FieldValue<TIM11_OR_TI1_RMP_Values, 2U, BaseType>;
    // 11: Channel1 is connected to GPIO
    using GPIO = FieldValue<TIM11_OR_TI1_RMP_Values, 3U, BaseType>;
};