/*******************************************************************************
* Filename      : Tim3FieldValues.hpp
*
* Details       : Enumerations related with TIM3 peripheral. This header file is
*                 auto-generated for STM32L152 device.
*
*
*******************************************************************************/

#pragma once

#include <register/FieldValue.hpp>

using namespace ng;

/**
 * Clock division
 *
 * This bit-field indicates the division ratio between the timer clock (CK_INT) frequency and
 * sampling clock used by the digital filters (ETR, TIx),
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CR1_CKD_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 00: tDTS = tCK_INT
    using ClockInt = FieldValue<TIM3_CR1_CKD_Values, 0U, BaseType>;
    // 01: tDTS = 2 × tCK_INT
    using ClockIntMul2 = FieldValue<TIM3_CR1_CKD_Values, 1U, BaseType>;
    // 10: tDTS = 4 × tCK_INT
    using ClockIntMul4 = FieldValue<TIM3_CR1_CKD_Values, 2U, BaseType>;
};

/** Auto-reload preload enable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CR1_ARPE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // register is not buffered
    using NotBuffered = FieldValue<TIM3_CR1_ARPE_Values, 0U, BaseType>;
    // register is buffered
    using Buffered = FieldValue<TIM3_CR1_ARPE_Values, 1U, BaseType>;
};

/**  Center-aligned mode selection */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CR1_CMS_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /** 00: Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR). */
    using EdgeAligned  = FieldValue<TIM3_CR1_CMS_Values, 0U, BaseType>;
    /**
     * 01: Center-aligned mode 1. The counter counts up and down alternatively. Output compare
     * interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set
     * only when the counter is counting down.
     */
    using CenterAligned1 = FieldValue<TIM3_CR1_CMS_Values, 1U, BaseType>;
    /**
     * 10: Center-aligned mode 2. The counter counts up and down alternatively. Output compare
     * interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set
     * only when the counter is counting up.
     */
    using CenterAligned2 = FieldValue<TIM3_CR1_CMS_Values, 2U, BaseType>;
    /**
     * 11: Center-aligned mode 3. The counter counts up and down alternatively. Output compare
     * interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set
     * both when the counter is counting up or down.
     */
    using CenterAligned3 = FieldValue<TIM3_CR1_CMS_Values, 3U, BaseType>;
};

/** Direction */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CR1_DIR_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Up = FieldValue<TIM3_CR1_DIR_Values, 0U, BaseType>;
    using Down = FieldValue<TIM3_CR1_DIR_Values, 1U, BaseType>;
};

/** One-pulse mode */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CR1_OPM_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // Counter is not stopped at update event
    using Disabled = FieldValue<TIM3_CR1_OPM_Values, 0U, BaseType>;
    // Counter stops counting at the next update event (clearing the CEN bit).
    using Enabled = FieldValue<TIM3_CR1_OPM_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CR1_URS_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /**
     * This bit is set and cleared by software to select the UEV event sources.
     * 0: Any of the following events generates an update interrupt or DMA request if enabled.
     * These events can be:
     *   – Counter overflow/underflow
     *   – Setting the UG bit
     *   – Update generation through the slave mode controller
     */
    using AllEvents = FieldValue<TIM3_CR1_URS_Values, 0U, BaseType>;
    /** 1: Only counter overflow/underflow generates an update interrupt or DMA request if enabled. */
    using CounterOverflow = FieldValue<TIM3_CR1_URS_Values, 1U, BaseType>;
};

/** Update disable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CR1_UDIS_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /**
     * 0: UEV enabled. The Update (UEV) event is generated by one of the following events:
     *
     *   – Counter overflow/underflow
     *   – Setting the UG bit
     *   – Update generation through the slave mode controller
     *
     * Buffered registers are then loaded with their preload values.
     */
    using UEVEnabled = FieldValue<TIM3_CR1_UDIS_Values, 0U, BaseType>;
    /**
     * 1: UEV disabled. The Update event is not generated, shadow registers keep their value
     * (ARR, PSC). However the counter and the prescaler are reinitialized if the UG bit is set or if
     * a hardware reset is received from the slave mode controller.
     */
    using UEVDisabled = FieldValue<TIM3_CR1_UDIS_Values, 1U, BaseType>;
};

/** Counter enable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CR1_CEN_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Disable = FieldValue<TIM3_CR1_CEN_Values, 0U, BaseType>;
    using Enable = FieldValue<TIM3_CR1_CEN_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CR2_TI1S_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CR2_TI1S_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CR2_TI1S_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CR2_MMS_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CR2_MMS_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CR2_MMS_Values, 1U, BaseType>;
    using Value2 = FieldValue<TIM3_CR2_MMS_Values, 2U, BaseType>;
    using Value3 = FieldValue<TIM3_CR2_MMS_Values, 3U, BaseType>;
    using Value4 = FieldValue<TIM3_CR2_MMS_Values, 4U, BaseType>;
    using Value5 = FieldValue<TIM3_CR2_MMS_Values, 5U, BaseType>;
    using Value6 = FieldValue<TIM3_CR2_MMS_Values, 6U, BaseType>;
    using Value7 = FieldValue<TIM3_CR2_MMS_Values, 7U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CR2_CCDS_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CR2_CCDS_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CR2_CCDS_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_SMCR_ETP_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_SMCR_ETP_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_SMCR_ETP_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_SMCR_ECE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_SMCR_ECE_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_SMCR_ECE_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_SMCR_ETPS_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_SMCR_ETPS_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_SMCR_ETPS_Values, 1U, BaseType>;
    using Value2 = FieldValue<TIM3_SMCR_ETPS_Values, 2U, BaseType>;
    using Value3 = FieldValue<TIM3_SMCR_ETPS_Values, 3U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_SMCR_ETF_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_SMCR_ETF_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_SMCR_ETF_Values, 1U, BaseType>;
    using Value2 = FieldValue<TIM3_SMCR_ETF_Values, 2U, BaseType>;
    using Value3 = FieldValue<TIM3_SMCR_ETF_Values, 3U, BaseType>;
    using Value4 = FieldValue<TIM3_SMCR_ETF_Values, 4U, BaseType>;
    using Value5 = FieldValue<TIM3_SMCR_ETF_Values, 5U, BaseType>;
    using Value6 = FieldValue<TIM3_SMCR_ETF_Values, 6U, BaseType>;
    using Value7 = FieldValue<TIM3_SMCR_ETF_Values, 7U, BaseType>;
    using Value8 = FieldValue<TIM3_SMCR_ETF_Values, 8U, BaseType>;
    using Value9 = FieldValue<TIM3_SMCR_ETF_Values, 9U, BaseType>;
    using Value10 = FieldValue<TIM3_SMCR_ETF_Values, 10U, BaseType>;
    using Value11 = FieldValue<TIM3_SMCR_ETF_Values, 11U, BaseType>;
    using Value12 = FieldValue<TIM3_SMCR_ETF_Values, 12U, BaseType>;
    using Value13 = FieldValue<TIM3_SMCR_ETF_Values, 13U, BaseType>;
    using Value14 = FieldValue<TIM3_SMCR_ETF_Values, 14U, BaseType>;
    using Value15 = FieldValue<TIM3_SMCR_ETF_Values, 15U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_SMCR_MSM_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_SMCR_MSM_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_SMCR_MSM_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_SMCR_TS_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_SMCR_TS_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_SMCR_TS_Values, 1U, BaseType>;
    using Value2 = FieldValue<TIM3_SMCR_TS_Values, 2U, BaseType>;
    using Value3 = FieldValue<TIM3_SMCR_TS_Values, 3U, BaseType>;
    using Value4 = FieldValue<TIM3_SMCR_TS_Values, 4U, BaseType>;
    using Value5 = FieldValue<TIM3_SMCR_TS_Values, 5U, BaseType>;
    using Value6 = FieldValue<TIM3_SMCR_TS_Values, 6U, BaseType>;
    using Value7 = FieldValue<TIM3_SMCR_TS_Values, 7U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_SMCR_OCCS_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_SMCR_OCCS_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_SMCR_OCCS_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_SMCR_SMS_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_SMCR_SMS_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_SMCR_SMS_Values, 1U, BaseType>;
    using Value2 = FieldValue<TIM3_SMCR_SMS_Values, 2U, BaseType>;
    using Value3 = FieldValue<TIM3_SMCR_SMS_Values, 3U, BaseType>;
    using Value4 = FieldValue<TIM3_SMCR_SMS_Values, 4U, BaseType>;
    using Value5 = FieldValue<TIM3_SMCR_SMS_Values, 5U, BaseType>;
    using Value6 = FieldValue<TIM3_SMCR_SMS_Values, 6U, BaseType>;
    using Value7 = FieldValue<TIM3_SMCR_SMS_Values, 7U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_DIER_TDE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_DIER_TDE_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_DIER_TDE_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_DIER_CC4DE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_DIER_CC4DE_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_DIER_CC4DE_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_DIER_CC3DE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_DIER_CC3DE_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_DIER_CC3DE_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_DIER_CC2DE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_DIER_CC2DE_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_DIER_CC2DE_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_DIER_CC1DE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_DIER_CC1DE_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_DIER_CC1DE_Values, 1U, BaseType>;
};

/** Update DMA request enable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_DIER_UDE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // Update DMA request disabled
    using Disabled = FieldValue<TIM3_DIER_UDE_Values, 0U, BaseType>;
    // Update DMA request enabled
    using Enabled = FieldValue<TIM3_DIER_UDE_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_DIER_TIE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_DIER_TIE_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_DIER_TIE_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_DIER_CC4IE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_DIER_CC4IE_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_DIER_CC4IE_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_DIER_CC3IE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_DIER_CC3IE_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_DIER_CC3IE_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_DIER_CC2IE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_DIER_CC2IE_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_DIER_CC2IE_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_DIER_CC1IE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_DIER_CC1IE_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_DIER_CC1IE_Values, 1U, BaseType>;
};

/** Update interrupt enable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_DIER_UIE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // Update interrupt disabled
    using Disabled = FieldValue<TIM3_DIER_UIE_Values, 0U, BaseType>;
    // Update interrupt enabled
    using Enabled = FieldValue<TIM3_DIER_UIE_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_SR_CC4OF_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_SR_CC4OF_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_SR_CC4OF_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_SR_CC3OF_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_SR_CC3OF_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_SR_CC3OF_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_SR_CC2OF_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_SR_CC2OF_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_SR_CC2OF_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_SR_CC1OF_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_SR_CC1OF_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_SR_CC1OF_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_SR_TIF_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_SR_TIF_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_SR_TIF_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_SR_CC4IF_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_SR_CC4IF_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_SR_CC4IF_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_SR_CC3IF_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_SR_CC3IF_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_SR_CC3IF_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_SR_CC2IF_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_SR_CC2IF_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_SR_CC2IF_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_SR_CC1IF_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_SR_CC1IF_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_SR_CC1IF_Values, 1U, BaseType>;
};

/**
 * Update interrupt flag.
 * This bit is set by hardware on an update event. It is cleared by software.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_SR_UIF_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // No update occurred.
    using Cleared = FieldValue<TIM3_SR_UIF_Values, 0U, BaseType>;
    /**
     * Update interrupt pending. This bit is set by hardware when the registers are updated:
     *   – At overflow or underflow and if UDIS = 0 in the TIMx_CR1 register.
     *   – When CNT is reinitialized by software using the UG bit in the TIMx_EGR register, if URS = 0
     *     and UDIS = 0 in the TIMx_CR1 register.
     */
    using Updated = FieldValue<TIM3_SR_UIF_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_EGR_TG_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_EGR_TG_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_EGR_TG_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_EGR_CC4G_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_EGR_CC4G_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_EGR_CC4G_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_EGR_CC3G_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_EGR_CC3G_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_EGR_CC3G_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_EGR_CC2G_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_EGR_CC2G_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_EGR_CC2G_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_EGR_CC1G_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_EGR_CC1G_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_EGR_CC1G_Values, 1U, BaseType>;
};

/** Update generation */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_EGR_UG_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using NoAction = FieldValue<TIM3_EGR_UG_Values, 0U, BaseType>;
    /**
     *  Re-initializes the timer counter and generates an update of the registers. Note that the
     *  prescaler counter is cleared too (but the prescaler ratio is not affected).
     */
    using ReInit = FieldValue<TIM3_EGR_UG_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR1_Output_OC2CE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCMR1_Output_OC2CE_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCMR1_Output_OC2CE_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR1_Output_OC2M_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCMR1_Output_OC2M_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCMR1_Output_OC2M_Values, 1U, BaseType>;
    using Value2 = FieldValue<TIM3_CCMR1_Output_OC2M_Values, 2U, BaseType>;
    using Value3 = FieldValue<TIM3_CCMR1_Output_OC2M_Values, 3U, BaseType>;
    using Value4 = FieldValue<TIM3_CCMR1_Output_OC2M_Values, 4U, BaseType>;
    using Value5 = FieldValue<TIM3_CCMR1_Output_OC2M_Values, 5U, BaseType>;
    using Value6 = FieldValue<TIM3_CCMR1_Output_OC2M_Values, 6U, BaseType>;
    using Value7 = FieldValue<TIM3_CCMR1_Output_OC2M_Values, 7U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR1_Output_OC2PE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCMR1_Output_OC2PE_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCMR1_Output_OC2PE_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR1_Output_OC2FE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCMR1_Output_OC2FE_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCMR1_Output_OC2FE_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR1_Output_CC2S_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCMR1_Output_CC2S_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCMR1_Output_CC2S_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR1_Output_OC1CE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCMR1_Output_OC1CE_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCMR1_Output_OC1CE_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR1_Output_OC1M_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCMR1_Output_OC1M_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCMR1_Output_OC1M_Values, 1U, BaseType>;
    using Value2 = FieldValue<TIM3_CCMR1_Output_OC1M_Values, 2U, BaseType>;
    using Value3 = FieldValue<TIM3_CCMR1_Output_OC1M_Values, 3U, BaseType>;
    using Value4 = FieldValue<TIM3_CCMR1_Output_OC1M_Values, 4U, BaseType>;
    using Value5 = FieldValue<TIM3_CCMR1_Output_OC1M_Values, 5U, BaseType>;
    using Value6 = FieldValue<TIM3_CCMR1_Output_OC1M_Values, 6U, BaseType>;
    using Value7 = FieldValue<TIM3_CCMR1_Output_OC1M_Values, 7U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR1_Output_OC1PE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCMR1_Output_OC1PE_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCMR1_Output_OC1PE_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR1_Output_OC1FE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCMR1_Output_OC1FE_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCMR1_Output_OC1FE_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR1_Output_CC1S_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCMR1_Output_CC1S_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCMR1_Output_CC1S_Values, 1U, BaseType>;
    using Value2 = FieldValue<TIM3_CCMR1_Output_CC1S_Values, 2U, BaseType>;
    using Value3 = FieldValue<TIM3_CCMR1_Output_CC1S_Values, 3U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR1_Input_IC2F_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCMR1_Input_IC2F_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCMR1_Input_IC2F_Values, 1U, BaseType>;
    using Value2 = FieldValue<TIM3_CCMR1_Input_IC2F_Values, 2U, BaseType>;
    using Value3 = FieldValue<TIM3_CCMR1_Input_IC2F_Values, 3U, BaseType>;
    using Value4 = FieldValue<TIM3_CCMR1_Input_IC2F_Values, 4U, BaseType>;
    using Value5 = FieldValue<TIM3_CCMR1_Input_IC2F_Values, 5U, BaseType>;
    using Value6 = FieldValue<TIM3_CCMR1_Input_IC2F_Values, 6U, BaseType>;
    using Value7 = FieldValue<TIM3_CCMR1_Input_IC2F_Values, 7U, BaseType>;
    using Value8 = FieldValue<TIM3_CCMR1_Input_IC2F_Values, 8U, BaseType>;
    using Value9 = FieldValue<TIM3_CCMR1_Input_IC2F_Values, 9U, BaseType>;
    using Value10 = FieldValue<TIM3_CCMR1_Input_IC2F_Values, 10U, BaseType>;
    using Value11 = FieldValue<TIM3_CCMR1_Input_IC2F_Values, 11U, BaseType>;
    using Value12 = FieldValue<TIM3_CCMR1_Input_IC2F_Values, 12U, BaseType>;
    using Value13 = FieldValue<TIM3_CCMR1_Input_IC2F_Values, 13U, BaseType>;
    using Value14 = FieldValue<TIM3_CCMR1_Input_IC2F_Values, 14U, BaseType>;
    using Value15 = FieldValue<TIM3_CCMR1_Input_IC2F_Values, 15U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR1_Input_IC2PCS_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCMR1_Input_IC2PCS_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCMR1_Input_IC2PCS_Values, 1U, BaseType>;
    using Value2 = FieldValue<TIM3_CCMR1_Input_IC2PCS_Values, 2U, BaseType>;
    using Value3 = FieldValue<TIM3_CCMR1_Input_IC2PCS_Values, 3U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR1_Input_CC2S_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCMR1_Input_CC2S_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCMR1_Input_CC2S_Values, 1U, BaseType>;
    using Value2 = FieldValue<TIM3_CCMR1_Input_CC2S_Values, 2U, BaseType>;
    using Value3 = FieldValue<TIM3_CCMR1_Input_CC2S_Values, 3U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR1_Input_IC1F_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCMR1_Input_IC1F_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCMR1_Input_IC1F_Values, 1U, BaseType>;
    using Value2 = FieldValue<TIM3_CCMR1_Input_IC1F_Values, 2U, BaseType>;
    using Value3 = FieldValue<TIM3_CCMR1_Input_IC1F_Values, 3U, BaseType>;
    using Value4 = FieldValue<TIM3_CCMR1_Input_IC1F_Values, 4U, BaseType>;
    using Value5 = FieldValue<TIM3_CCMR1_Input_IC1F_Values, 5U, BaseType>;
    using Value6 = FieldValue<TIM3_CCMR1_Input_IC1F_Values, 6U, BaseType>;
    using Value7 = FieldValue<TIM3_CCMR1_Input_IC1F_Values, 7U, BaseType>;
    using Value8 = FieldValue<TIM3_CCMR1_Input_IC1F_Values, 8U, BaseType>;
    using Value9 = FieldValue<TIM3_CCMR1_Input_IC1F_Values, 9U, BaseType>;
    using Value10 = FieldValue<TIM3_CCMR1_Input_IC1F_Values, 10U, BaseType>;
    using Value11 = FieldValue<TIM3_CCMR1_Input_IC1F_Values, 11U, BaseType>;
    using Value12 = FieldValue<TIM3_CCMR1_Input_IC1F_Values, 12U, BaseType>;
    using Value13 = FieldValue<TIM3_CCMR1_Input_IC1F_Values, 13U, BaseType>;
    using Value14 = FieldValue<TIM3_CCMR1_Input_IC1F_Values, 14U, BaseType>;
    using Value15 = FieldValue<TIM3_CCMR1_Input_IC1F_Values, 15U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR1_Input_ICPCS_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCMR1_Input_ICPCS_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCMR1_Input_ICPCS_Values, 1U, BaseType>;
    using Value2 = FieldValue<TIM3_CCMR1_Input_ICPCS_Values, 2U, BaseType>;
    using Value3 = FieldValue<TIM3_CCMR1_Input_ICPCS_Values, 3U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR1_Input_CC1S_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCMR1_Input_CC1S_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCMR1_Input_CC1S_Values, 1U, BaseType>;
    using Value2 = FieldValue<TIM3_CCMR1_Input_CC1S_Values, 2U, BaseType>;
    using Value3 = FieldValue<TIM3_CCMR1_Input_CC1S_Values, 3U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR2_Output_OC4CE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCMR2_Output_OC4CE_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCMR2_Output_OC4CE_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR2_Output_OC4M_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCMR2_Output_OC4M_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCMR2_Output_OC4M_Values, 1U, BaseType>;
    using Value2 = FieldValue<TIM3_CCMR2_Output_OC4M_Values, 2U, BaseType>;
    using Value3 = FieldValue<TIM3_CCMR2_Output_OC4M_Values, 3U, BaseType>;
    using Value4 = FieldValue<TIM3_CCMR2_Output_OC4M_Values, 4U, BaseType>;
    using Value5 = FieldValue<TIM3_CCMR2_Output_OC4M_Values, 5U, BaseType>;
    using Value6 = FieldValue<TIM3_CCMR2_Output_OC4M_Values, 6U, BaseType>;
    using Value7 = FieldValue<TIM3_CCMR2_Output_OC4M_Values, 7U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR2_Output_OC4PE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCMR2_Output_OC4PE_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCMR2_Output_OC4PE_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR2_Output_OC4FE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCMR2_Output_OC4FE_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCMR2_Output_OC4FE_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR2_Output_CC4S_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCMR2_Output_CC4S_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCMR2_Output_CC4S_Values, 1U, BaseType>;
};

/**  Output compare clear enable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR2_Output_OC3CE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 0: OC1Ref is not affected by the ETRF input
    using Value0 = FieldValue<TIM3_CCMR2_Output_OC3CE_Values, 0U, BaseType>;
    // 1: OC1Ref is cleared as soon as a High level is detected on ETRF input
    using Value1 = FieldValue<TIM3_CCMR2_Output_OC3CE_Values, 1U, BaseType>;
};

/**
 * Output compare mode
 *
 * These bits define the behavior of the output reference signal OCxREF from which OCx and
 * OCxN are derived. OCxREF is active high whereas OCx and OCxN active level depends
 * on CCxP and CCxNP bits.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR2_Output_OC3M_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /**
     * 000: Frozen - The comparison between the output compare register TIMx_CCRx and the
     * counter TIMx_CNT has no effect on the outputs.(this mode is used to generate a timing base).
     */
    using Frozen = FieldValue<TIM3_CCMR2_Output_OC3M_Values, 0U, BaseType>;
    /**
     * 001: Set channel 1 to active level on match. OCxREF signal is forced high when the counter
     * TIMx_CNT matches the capture/compare register 1 (TIMx_CCRx).
     */
    using ActiveLevelOnMatch = FieldValue<TIM3_CCMR2_Output_OC3M_Values, 1U, BaseType>;
    /**
     * 010: Set channel 1 to inactive level on match. OCxREF signal is forced low when the counter
     * TIMx_CNT matches the capture/compare register 1 (TIMx_CCRx).
     */
    using InactiveLevelOnMatch = FieldValue<TIM3_CCMR2_Output_OC3M_Values, 2U, BaseType>;
    // 011: Toggle - OCxREF toggles when TIMx_CNT=TIMx_CCRx.
    using Toggle = FieldValue<TIM3_CCMR2_Output_OC3M_Values, 3U, BaseType>;
    // 100: Force inactive level - OCxREF is forced low.
    using ForceInactive = FieldValue<TIM3_CCMR2_Output_OC3M_Values, 4U, BaseType>;
    // 101: Force active level - OCxREF is forced high.
    using ForceActive = FieldValue<TIM3_CCMR2_Output_OC3M_Values, 5U, BaseType>;
    /**
     * 110: PWM mode 1 - In upcounting, channel 1 is active as long as TIMx_CNT<TIMx_CCRx
     * else inactive. In downcounting, channel 1 is inactive (OCxREF=‘0) as long as
     * TIMx_CNT > TIMx_CCRx else active (OCxREF=1).
     */
    using PWM1 = FieldValue<TIM3_CCMR2_Output_OC3M_Values, 6U, BaseType>;
    /**
     * 111: PWM mode 2 - In upcounting, channel 1 is inactive as long as TIMx_CNT<TIMx_CCRx
     * else active. In downcounting, channel 1 is active as long as TIMx_CNT > TIMx_CCRx else inactive
     */
    using PWM2 = FieldValue<TIM3_CCMR2_Output_OC3M_Values, 7U, BaseType>;
};

/** Output compare preload enable */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR2_Output_OC3PE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /**
     * 0: Preload register on TIMx_CCRx disabled. TIMx_CCRx can be written at anytime, the
     * new value is taken in account immediately
     */
    using Disabled = FieldValue<TIM3_CCMR2_Output_OC3PE_Values, 0U, BaseType>;
    /**
     * 1: Preload register on TIMx_CCRx enabled. Read/Write operations access the preload
     * register. TIMx_CCRx preload value is loaded in the active register at each update event.
     */
    using Enabled = FieldValue<TIM3_CCMR2_Output_OC3PE_Values, 1U, BaseType>;
};

/**
 * Output compare fast enable.
 * This bit is used to accelerate the effect of an event on the trigger in input on the CC output.
 * */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR2_Output_OC3FE_Values : public RegisterField<Reg, offset, size, AccessMode> {
    /**
     * 0: CCx behaves normally depending on the counter and CCRx values even when the
     * trigger is ON. The minimum delay to activate the CCx output when an edge occurs on the
     * trigger input is 5 clock cycles
     */
    using Nornal = FieldValue<TIM3_CCMR2_Output_OC3FE_Values, 0U, BaseType>;
    /**
     * 1: An active edge on the trigger input acts like a compare match on the CCx output. Then,
     * OC is set to the compare level independently of the result of the comparison. Delay to
     * sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OC1FE
     * acts only if the channel is configured in PWM1 or PWM2 mode.
     */
    using Fast = FieldValue<TIM3_CCMR2_Output_OC3FE_Values, 1U, BaseType>;
};

/**
 * Capture/Compare selection.
 * This bitfield defines the direction of the channel (input/output) as well as the used input.
 */
template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR2_Output_CC3S_Values : public RegisterField<Reg, offset, size, AccessMode> {
    // 00: CC1 channel is configured as output
    using Output = FieldValue<TIM3_CCMR2_Output_CC3S_Values, 0U, BaseType>;
    // 01: CC1 channel is configured as input, IC1 is mapped on TI1
    using InputTI1 = FieldValue<TIM3_CCMR2_Output_CC3S_Values, 1U, BaseType>;
    // 10: CC1 channel is configured as input, IC1 is mapped on TI2
    using InputTI2 = FieldValue<TIM3_CCMR2_Output_CC3S_Values, 2U, BaseType>;
    // 11: CC1 channel is configured as input, IC1 is mapped on TRC. This mode works only if an
    //internal trigger input is selected through the TS bit (TIMx_SMCR register)
    using InputTRC = FieldValue<TIM3_CCMR2_Output_CC3S_Values, 3U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR2_Input_IC4F_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCMR2_Input_IC4F_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCMR2_Input_IC4F_Values, 1U, BaseType>;
    using Value2 = FieldValue<TIM3_CCMR2_Input_IC4F_Values, 2U, BaseType>;
    using Value3 = FieldValue<TIM3_CCMR2_Input_IC4F_Values, 3U, BaseType>;
    using Value4 = FieldValue<TIM3_CCMR2_Input_IC4F_Values, 4U, BaseType>;
    using Value5 = FieldValue<TIM3_CCMR2_Input_IC4F_Values, 5U, BaseType>;
    using Value6 = FieldValue<TIM3_CCMR2_Input_IC4F_Values, 6U, BaseType>;
    using Value7 = FieldValue<TIM3_CCMR2_Input_IC4F_Values, 7U, BaseType>;
    using Value8 = FieldValue<TIM3_CCMR2_Input_IC4F_Values, 8U, BaseType>;
    using Value9 = FieldValue<TIM3_CCMR2_Input_IC4F_Values, 9U, BaseType>;
    using Value10 = FieldValue<TIM3_CCMR2_Input_IC4F_Values, 10U, BaseType>;
    using Value11 = FieldValue<TIM3_CCMR2_Input_IC4F_Values, 11U, BaseType>;
    using Value12 = FieldValue<TIM3_CCMR2_Input_IC4F_Values, 12U, BaseType>;
    using Value13 = FieldValue<TIM3_CCMR2_Input_IC4F_Values, 13U, BaseType>;
    using Value14 = FieldValue<TIM3_CCMR2_Input_IC4F_Values, 14U, BaseType>;
    using Value15 = FieldValue<TIM3_CCMR2_Input_IC4F_Values, 15U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR2_Input_IC4PSC_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCMR2_Input_IC4PSC_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCMR2_Input_IC4PSC_Values, 1U, BaseType>;
    using Value2 = FieldValue<TIM3_CCMR2_Input_IC4PSC_Values, 2U, BaseType>;
    using Value3 = FieldValue<TIM3_CCMR2_Input_IC4PSC_Values, 3U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR2_Input_CC4S_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCMR2_Input_CC4S_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCMR2_Input_CC4S_Values, 1U, BaseType>;
    using Value2 = FieldValue<TIM3_CCMR2_Input_CC4S_Values, 2U, BaseType>;
    using Value3 = FieldValue<TIM3_CCMR2_Input_CC4S_Values, 3U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR2_Input_IC3F_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCMR2_Input_IC3F_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCMR2_Input_IC3F_Values, 1U, BaseType>;
    using Value2 = FieldValue<TIM3_CCMR2_Input_IC3F_Values, 2U, BaseType>;
    using Value3 = FieldValue<TIM3_CCMR2_Input_IC3F_Values, 3U, BaseType>;
    using Value4 = FieldValue<TIM3_CCMR2_Input_IC3F_Values, 4U, BaseType>;
    using Value5 = FieldValue<TIM3_CCMR2_Input_IC3F_Values, 5U, BaseType>;
    using Value6 = FieldValue<TIM3_CCMR2_Input_IC3F_Values, 6U, BaseType>;
    using Value7 = FieldValue<TIM3_CCMR2_Input_IC3F_Values, 7U, BaseType>;
    using Value8 = FieldValue<TIM3_CCMR2_Input_IC3F_Values, 8U, BaseType>;
    using Value9 = FieldValue<TIM3_CCMR2_Input_IC3F_Values, 9U, BaseType>;
    using Value10 = FieldValue<TIM3_CCMR2_Input_IC3F_Values, 10U, BaseType>;
    using Value11 = FieldValue<TIM3_CCMR2_Input_IC3F_Values, 11U, BaseType>;
    using Value12 = FieldValue<TIM3_CCMR2_Input_IC3F_Values, 12U, BaseType>;
    using Value13 = FieldValue<TIM3_CCMR2_Input_IC3F_Values, 13U, BaseType>;
    using Value14 = FieldValue<TIM3_CCMR2_Input_IC3F_Values, 14U, BaseType>;
    using Value15 = FieldValue<TIM3_CCMR2_Input_IC3F_Values, 15U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR2_Input_IC3PSC_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCMR2_Input_IC3PSC_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCMR2_Input_IC3PSC_Values, 1U, BaseType>;
    using Value2 = FieldValue<TIM3_CCMR2_Input_IC3PSC_Values, 2U, BaseType>;
    using Value3 = FieldValue<TIM3_CCMR2_Input_IC3PSC_Values, 3U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCMR2_Input_CC3S_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCMR2_Input_CC3S_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCMR2_Input_CC3S_Values, 1U, BaseType>;
    using Value2 = FieldValue<TIM3_CCMR2_Input_CC3S_Values, 2U, BaseType>;
    using Value3 = FieldValue<TIM3_CCMR2_Input_CC3S_Values, 3U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCER_CC4NP_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCER_CC4NP_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCER_CC4NP_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCER_CC4P_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCER_CC4P_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCER_CC4P_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCER_CC4E_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCER_CC4E_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCER_CC4E_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCER_CC3NP_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCER_CC3NP_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCER_CC3NP_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCER_CC3P_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCER_CC3P_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCER_CC3P_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCER_CC3E_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCER_CC3E_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCER_CC3E_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCER_CC2NP_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCER_CC2NP_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCER_CC2NP_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCER_CC2P_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCER_CC2P_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCER_CC2P_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCER_CC2E_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCER_CC2E_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCER_CC2E_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCER_CC1NP_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCER_CC1NP_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCER_CC1NP_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCER_CC1P_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCER_CC1P_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCER_CC1P_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCER_CC1E_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_CCER_CC1E_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_CCER_CC1E_Values, 1U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CNT_CNT_Values : public RegisterField<Reg, offset, size, AccessMode> {
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_PSC_PSC_Values : public RegisterField<Reg, offset, size, AccessMode> {
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_ARR_ARR_Values : public RegisterField<Reg, offset, size, AccessMode> {
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCR1_CCR1_Values : public RegisterField<Reg, offset, size, AccessMode> {
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCR2_CCR2_Values : public RegisterField<Reg, offset, size, AccessMode> {
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCR3_CCR1_Values : public RegisterField<Reg, offset, size, AccessMode> {
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_CCR4_CCR4_Values : public RegisterField<Reg, offset, size, AccessMode> {
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_DCR_DBL_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_DCR_DBL_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_DCR_DBL_Values, 1U, BaseType>;
    using Value2 = FieldValue<TIM3_DCR_DBL_Values, 2U, BaseType>;
    using Value3 = FieldValue<TIM3_DCR_DBL_Values, 3U, BaseType>;
    using Value4 = FieldValue<TIM3_DCR_DBL_Values, 4U, BaseType>;
    using Value5 = FieldValue<TIM3_DCR_DBL_Values, 5U, BaseType>;
    using Value6 = FieldValue<TIM3_DCR_DBL_Values, 6U, BaseType>;
    using Value7 = FieldValue<TIM3_DCR_DBL_Values, 7U, BaseType>;
    using Value8 = FieldValue<TIM3_DCR_DBL_Values, 8U, BaseType>;
    using Value9 = FieldValue<TIM3_DCR_DBL_Values, 9U, BaseType>;
    using Value10 = FieldValue<TIM3_DCR_DBL_Values, 10U, BaseType>;
    using Value11 = FieldValue<TIM3_DCR_DBL_Values, 11U, BaseType>;
    using Value12 = FieldValue<TIM3_DCR_DBL_Values, 12U, BaseType>;
    using Value13 = FieldValue<TIM3_DCR_DBL_Values, 13U, BaseType>;
    using Value14 = FieldValue<TIM3_DCR_DBL_Values, 14U, BaseType>;
    using Value15 = FieldValue<TIM3_DCR_DBL_Values, 15U, BaseType>;
    using Value16 = FieldValue<TIM3_DCR_DBL_Values, 16U, BaseType>;
    using Value17 = FieldValue<TIM3_DCR_DBL_Values, 17U, BaseType>;
    using Value18 = FieldValue<TIM3_DCR_DBL_Values, 18U, BaseType>;
    using Value19 = FieldValue<TIM3_DCR_DBL_Values, 19U, BaseType>;
    using Value20 = FieldValue<TIM3_DCR_DBL_Values, 20U, BaseType>;
    using Value21 = FieldValue<TIM3_DCR_DBL_Values, 21U, BaseType>;
    using Value22 = FieldValue<TIM3_DCR_DBL_Values, 22U, BaseType>;
    using Value23 = FieldValue<TIM3_DCR_DBL_Values, 23U, BaseType>;
    using Value24 = FieldValue<TIM3_DCR_DBL_Values, 24U, BaseType>;
    using Value25 = FieldValue<TIM3_DCR_DBL_Values, 25U, BaseType>;
    using Value26 = FieldValue<TIM3_DCR_DBL_Values, 26U, BaseType>;
    using Value27 = FieldValue<TIM3_DCR_DBL_Values, 27U, BaseType>;
    using Value28 = FieldValue<TIM3_DCR_DBL_Values, 28U, BaseType>;
    using Value29 = FieldValue<TIM3_DCR_DBL_Values, 29U, BaseType>;
    using Value30 = FieldValue<TIM3_DCR_DBL_Values, 30U, BaseType>;
    using Value31 = FieldValue<TIM3_DCR_DBL_Values, 31U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_DCR_DBA_Values : public RegisterField<Reg, offset, size, AccessMode> {
    using Value0 = FieldValue<TIM3_DCR_DBA_Values, 0U, BaseType>;
    using Value1 = FieldValue<TIM3_DCR_DBA_Values, 1U, BaseType>;
    using Value2 = FieldValue<TIM3_DCR_DBA_Values, 2U, BaseType>;
    using Value3 = FieldValue<TIM3_DCR_DBA_Values, 3U, BaseType>;
    using Value4 = FieldValue<TIM3_DCR_DBA_Values, 4U, BaseType>;
    using Value5 = FieldValue<TIM3_DCR_DBA_Values, 5U, BaseType>;
    using Value6 = FieldValue<TIM3_DCR_DBA_Values, 6U, BaseType>;
    using Value7 = FieldValue<TIM3_DCR_DBA_Values, 7U, BaseType>;
    using Value8 = FieldValue<TIM3_DCR_DBA_Values, 8U, BaseType>;
    using Value9 = FieldValue<TIM3_DCR_DBA_Values, 9U, BaseType>;
    using Value10 = FieldValue<TIM3_DCR_DBA_Values, 10U, BaseType>;
    using Value11 = FieldValue<TIM3_DCR_DBA_Values, 11U, BaseType>;
    using Value12 = FieldValue<TIM3_DCR_DBA_Values, 12U, BaseType>;
    using Value13 = FieldValue<TIM3_DCR_DBA_Values, 13U, BaseType>;
    using Value14 = FieldValue<TIM3_DCR_DBA_Values, 14U, BaseType>;
    using Value15 = FieldValue<TIM3_DCR_DBA_Values, 15U, BaseType>;
    using Value16 = FieldValue<TIM3_DCR_DBA_Values, 16U, BaseType>;
    using Value17 = FieldValue<TIM3_DCR_DBA_Values, 17U, BaseType>;
    using Value18 = FieldValue<TIM3_DCR_DBA_Values, 18U, BaseType>;
    using Value19 = FieldValue<TIM3_DCR_DBA_Values, 19U, BaseType>;
    using Value20 = FieldValue<TIM3_DCR_DBA_Values, 20U, BaseType>;
    using Value21 = FieldValue<TIM3_DCR_DBA_Values, 21U, BaseType>;
    using Value22 = FieldValue<TIM3_DCR_DBA_Values, 22U, BaseType>;
    using Value23 = FieldValue<TIM3_DCR_DBA_Values, 23U, BaseType>;
    using Value24 = FieldValue<TIM3_DCR_DBA_Values, 24U, BaseType>;
    using Value25 = FieldValue<TIM3_DCR_DBA_Values, 25U, BaseType>;
    using Value26 = FieldValue<TIM3_DCR_DBA_Values, 26U, BaseType>;
    using Value27 = FieldValue<TIM3_DCR_DBA_Values, 27U, BaseType>;
    using Value28 = FieldValue<TIM3_DCR_DBA_Values, 28U, BaseType>;
    using Value29 = FieldValue<TIM3_DCR_DBA_Values, 29U, BaseType>;
    using Value30 = FieldValue<TIM3_DCR_DBA_Values, 30U, BaseType>;
    using Value31 = FieldValue<TIM3_DCR_DBA_Values, 31U, BaseType>;
};

template<typename Reg, size_t offset, size_t size, typename AccessMode, typename BaseType>
struct TIM3_DMAR_DMAB_Values : public RegisterField<Reg, offset, size, AccessMode> {
};

